{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/2.jpg","path":"img/2.jpg","modified":1,"renderable":0},{"_id":"source/img/cv1.jpg","path":"img/cv1.jpg","modified":1,"renderable":0},{"_id":"source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":0},{"_id":"source/img/1.jpg","path":"img/1.jpg","modified":1,"renderable":0},{"_id":"source/img/ker1.jpg","path":"img/ker1.jpg","modified":1,"renderable":0},{"_id":"source/img/3.jpg","path":"img/3.jpg","modified":1,"renderable":0},{"_id":"themes/aircloud/source/css/aircloud.css","path":"css/aircloud.css","modified":1,"renderable":1},{"_id":"themes/aircloud/source/css/aircloud.css.map","path":"css/aircloud.css.map","modified":1,"renderable":1},{"_id":"themes/aircloud/source/css/aircloud.less","path":"css/aircloud.less","modified":1,"renderable":1},{"_id":"themes/aircloud/source/css/gitment.css","path":"css/gitment.css","modified":1,"renderable":1},{"_id":"themes/aircloud/source/js/index.js","path":"js/index.js","modified":1,"renderable":1},{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":0},{"_id":"source/img/kds.jpg","path":"img/kds.jpg","modified":1,"renderable":0},{"_id":"themes/aircloud/source/js/gitment.js","path":"js/gitment.js","modified":1,"renderable":1},{"_id":"source/img/donate.jpg","path":"img/donate.jpg","modified":1,"renderable":0},{"_id":"source/img/kd.jpg","path":"img/kd.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"themes/aircloud/.git","hash":"88a226fa8205173f10fe28625a2fde6ee48f88b7","modified":1610022992114},{"_id":"themes/aircloud/.gitignore","hash":"5a4a925cfd624633dafaacaced416c8d7272dcef","modified":1610022992191},{"_id":"themes/aircloud/LICENSE","hash":"218b4bf797149a2751a015812a9adefe368185c1","modified":1610022992191},{"_id":"themes/aircloud/_config.yml","hash":"0ad3a6ab2c9bb07fb1e030052622fdcde5c6f28a","modified":1610022992191},{"_id":"themes/aircloud/readme-en.md","hash":"2903b1e9db12cd72ed6f8c10be14cd7f6afd82cf","modified":1610022992194},{"_id":"themes/aircloud/readme.md","hash":"4be1fc64bd1dc335a986a39594564e89bd7eba43","modified":1610022992195},{"_id":"source/404.md","hash":"83c2c6d587beaa967a976e5969d60fa97fcdbe55","modified":1610022984365},{"_id":"themes/aircloud/layout/catagory.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1610022992193},{"_id":"themes/aircloud/layout/page.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1610022992193},{"_id":"source/about/index.md","hash":"44d3bfe66e4be4fd86ac485f4e5fc5e36febb894","modified":1610022984376},{"_id":"source/_posts/深入浏览器web渲染与优化-续.md","hash":"917308065bce9eada9020f3122f1a24d8cf0c7e5","modified":1610022984375},{"_id":"source/tags/index.md","hash":"4e3dfcd992b0772a4b8b034fe41ead1cc7ce9903","modified":1610022984397},{"_id":"source/_posts/深入浏览器web渲染与优化.md","hash":"4d8b47d007a6f60f31bcf7f795f395d05989e87c","modified":1610022984375},{"_id":"source/img/2.jpg","hash":"2f5b0345c366a264ed5b685e464a84e592ac0017","modified":1610022984378},{"_id":"source/img/cv1.jpg","hash":"2160c839498ddf205bdbeb0d612da9338fc39500","modified":1610022984382},{"_id":"source/img/favicon.ico","hash":"6ed6db9af6e0d7b20e62a81d36d0556f47781d28","modified":1610022984387},{"_id":"themes/aircloud/languages/zh.yml","hash":"9ffaff1f5d240c94e44f9ef3b02bbae146af0dd4","modified":1610022992192},{"_id":"themes/aircloud/languages/en.yml","hash":"f3dd50ca369974ac7d335fb1cfabf4ebb04a64fa","modified":1610022992191},{"_id":"themes/aircloud/layout/404.ejs","hash":"8a30233a7b99831bd771121b5f450aaba412e8d5","modified":1610022992192},{"_id":"themes/aircloud/layout/about.ejs","hash":"cec034166ce08d2f8c961178e07b2f0ceac95cf2","modified":1610022992193},{"_id":"themes/aircloud/layout/archive.ejs","hash":"0f8a062f4f2f0648b23bd8c4a21945a6ca60dc1f","modified":1610022992193},{"_id":"themes/aircloud/layout/layout.ejs","hash":"7efd113aee90e698e187d0ea1f0b42a1c00d210e","modified":1610022992193},{"_id":"themes/aircloud/layout/index.ejs","hash":"09e2407d615be7fe7ac41d11df3b7026e7393080","modified":1610022992193},{"_id":"themes/aircloud/layout/post.ejs","hash":"2eb5fc0c2bb801528c3db3b09e6cb4d073e3ad99","modified":1610022992194},{"_id":"themes/aircloud/layout/tags.ejs","hash":"1a174d9213d25d9bf6ef28aabdaea6661cdd88c8","modified":1610022992194},{"_id":"source/img/1.jpg","hash":"f667d88d44741ff7b92ee9db5f1994bbcc05311c","modified":1610022984377},{"_id":"source/img/ker1.jpg","hash":"708e619ae0ad4524c41665f9930d3b8240d9ddcd","modified":1610022984397},{"_id":"themes/aircloud/source/_less/about.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1610022992198},{"_id":"themes/aircloud/source/_less/about.less","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1610022992198},{"_id":"themes/aircloud/source/_less/diff.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1610022992199},{"_id":"themes/aircloud/source/_less/diff.less","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1610022992199},{"_id":"themes/aircloud/source/_less/page.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1610022992203},{"_id":"themes/aircloud/source/_less/page.less","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1610022992203},{"_id":"themes/aircloud/source/_less/theme.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1610022992204},{"_id":"themes/aircloud/source/_less/theme.less","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1610022992204},{"_id":"source/img/3.jpg","hash":"2de0cbd6ef6695f024865eb614e849641d369b87","modified":1610022984379},{"_id":"themes/aircloud/layout/_partial/donate.ejs","hash":"81c976a3b7fa5c47ef61181d537220eaf1d55eac","modified":1610022992192},{"_id":"themes/aircloud/layout/_partial/head.ejs","hash":"3f18d5d4951a205bab25b08d6bf85b054c84a21b","modified":1610022992192},{"_id":"themes/aircloud/layout/_partial/nav.ejs","hash":"079fa72aa7a02ee11f6a44a8a9e58eb80fe28190","modified":1610022992192},{"_id":"themes/aircloud/layout/_partial/footer.ejs","hash":"33db88f1b03548c5181c04d44387dc68a9c4cdf6","modified":1610022992192},{"_id":"themes/aircloud/layout/_partial/toc.ejs","hash":"41d11d159011466f0b6272aca9a74df8642b693f","modified":1610022992193},{"_id":"themes/aircloud/source/_less/archive.css","hash":"905efcc06a62d1e8b60df0e12434afa353378d3a","modified":1610022992198},{"_id":"themes/aircloud/source/_less/archive.less","hash":"5538d38614960e69b97a7f80f38b5933851212b8","modified":1610022992198},{"_id":"themes/aircloud/source/_less/common.css","hash":"64914aa6ecd5b948676870e0809e0f220b162e3b","modified":1610022992199},{"_id":"themes/aircloud/source/_less/common.less","hash":"8aef4d8cfdefbcd2e28d4985a4f79a5005ca0b6c","modified":1610022992199},{"_id":"themes/aircloud/source/_less/donate.css","hash":"ae6a676a42321512f0536c5230bb53084aaf2c2f","modified":1610022992200},{"_id":"themes/aircloud/source/_less/donate.less","hash":"d63139f4aa148bf894afa5c1007a4398696a0e4c","modified":1610022992200},{"_id":"themes/aircloud/source/_less/gitment.css","hash":"7d560b64e367129f98424052c660ae82b03a1d02","modified":1610022992200},{"_id":"themes/aircloud/source/_less/gitment.less","hash":"916deb8ecdee798d7a9b43b544e31dfd5bbd6de4","modified":1610022992201},{"_id":"themes/aircloud/source/_less/hightlight.css","hash":"4e5a9ec3e88fbc2ce0faabceff8d3f5099ea1012","modified":1610022992201},{"_id":"themes/aircloud/source/_less/hightlight.less","hash":"4e5a9ec3e88fbc2ce0faabceff8d3f5099ea1012","modified":1610022992201},{"_id":"themes/aircloud/source/_less/index.css","hash":"52fe4d1b93dfb4c9c9d63e24862354b6a0ef47f8","modified":1610022992201},{"_id":"themes/aircloud/source/_less/index.less","hash":"502d689e3568056cc27dd4da7da2499b0be4253e","modified":1610022992202},{"_id":"themes/aircloud/source/_less/layout.css","hash":"40d7cadf42b130ea1b40de1ae73b2b00e27f476f","modified":1610022992202},{"_id":"themes/aircloud/source/_less/layout.less","hash":"194ac7db2eeee7307fcb7470302f8172100181fb","modified":1610022992202},{"_id":"themes/aircloud/source/_less/nav.css","hash":"32e352d71dc2e67d69a26d8b5116a27d8d2a7718","modified":1610022992202},{"_id":"themes/aircloud/source/_less/nav.less","hash":"627e33cafb4ca9c191053b10917fc21c68c6ee8c","modified":1610022992203},{"_id":"themes/aircloud/source/_less/post.css","hash":"4adf531589cb55413264c188b29ae47ab703beb8","modified":1610022992203},{"_id":"themes/aircloud/source/_less/post.less","hash":"bbbd81c03e7581950d82bf971eda49e8bed7bee1","modified":1610022992203},{"_id":"themes/aircloud/source/_less/tag.css","hash":"3250887aaae0bc62bd82082d000ce3de8cc55ab6","modified":1610022992204},{"_id":"themes/aircloud/source/_less/tag.less","hash":"47e1ce2f55e2b62beefd0f69dfe7deb594e7b309","modified":1610022992204},{"_id":"themes/aircloud/source/_less/toc.css","hash":"83b1a219e7fe66d9d6cc34600e5a16311381a883","modified":1610022992205},{"_id":"themes/aircloud/source/_less/toc.less","hash":"c873ce552b22b0aa2c51a386a91516cadf9160ba","modified":1610022992205},{"_id":"themes/aircloud/source/_less/variables.css","hash":"9768d38beea904c4febc704192a49c8f7ae6e06c","modified":1610022992205},{"_id":"themes/aircloud/source/_less/variables.less","hash":"49503f7a6c51edd6f1dbdea5345df6bb903b18a5","modified":1610022992205},{"_id":"themes/aircloud/source/css/aircloud.css","hash":"e6082557a5f0e546169ab1aa0ba29bda4ef5c182","modified":1610022992206},{"_id":"themes/aircloud/source/css/aircloud.css.map","hash":"50db34961d11f6f461e23912609d25141068a6fc","modified":1610022992206},{"_id":"themes/aircloud/source/css/aircloud.less","hash":"45cab2da310dbfcba37ac3db657db77b4adac60d","modified":1610022992207},{"_id":"themes/aircloud/source/css/gitment.css","hash":"926b553be983d6dd90bcb60c5d6d4ee215d268a6","modified":1610022992207},{"_id":"themes/aircloud/source/js/index.js","hash":"1fed4485eedf5309e504aec35596955e5d692c7d","modified":1610022992209},{"_id":"source/img/avatar.jpg","hash":"5304e3982426a771746874abc1e70bc93261e197","modified":1610022984381},{"_id":"source/img/kds.jpg","hash":"70558c28dbc717528049673f7653804596e45fde","modified":1610022984396},{"_id":"themes/aircloud/source/_less/_partial/footer.css","hash":"e00d722211b4695449d72850340ac0dd701d6ede","modified":1610022992196},{"_id":"themes/aircloud/source/_less/_partial/footer.css.map","hash":"9e8d4df5d08425de5a8b247d0dd8b805c6edc661","modified":1610022992196},{"_id":"themes/aircloud/source/_less/_partial/footer.less","hash":"d1469f97daf750f3e4be18c4d640772780c32a75","modified":1610022992197},{"_id":"themes/aircloud/source/js/gitment.js","hash":"89687f8fffe1125e08323fd6635ca4e53771c05e","modified":1610022992208},{"_id":"source/img/donate.jpg","hash":"bae2b0f605495463a161716e35884b9c8f23a7a1","modified":1610022984386},{"_id":"source/img/kd.jpg","hash":"37b74057d1c06436c4c8c1b191b86ff6593fca16","modified":1610022984394},{"_id":"public/search.json","hash":"5c1fca2fea7ac1cbefcf82c38e72f36676069d03","modified":1610023742461},{"_id":"public/404.html","hash":"1031b9e653eed218b80ad413592e7553144aa13b","modified":1610023742501},{"_id":"public/about/index.html","hash":"68a689668773bec029e3f06e3e1d4c9a68e51d8b","modified":1610023742501},{"_id":"public/tags/index.html","hash":"9da4b50347e100c615a27b3e50eaca3f14c47f22","modified":1610023742501},{"_id":"public/index.html","hash":"dea4ca1d3201a97fdd7ecee00102ef0ff8cbf9ad","modified":1610023742501},{"_id":"public/tags/性能优化/index.html","hash":"ec7f5016ef4c7d065842d728804c6c9e9af25650","modified":1610023742501},{"_id":"public/archive/2017/index.html","hash":"79a878c8f5faf85076b1e2bcad60300deb4c23dd","modified":1610023742501},{"_id":"public/archive/index.html","hash":"79a878c8f5faf85076b1e2bcad60300deb4c23dd","modified":1610023742501},{"_id":"public/archive/2017/08/index.html","hash":"79a878c8f5faf85076b1e2bcad60300deb4c23dd","modified":1610023742501},{"_id":"public/2017/08/31/深入浏览器web渲染与优化-续/index.html","hash":"90c22cf166350f0530b4ef3df866956737836b23","modified":1610023742501},{"_id":"public/2017/08/27/深入浏览器web渲染与优化/index.html","hash":"a4d79309d711788e6cc3feee1e4aec10477549b6","modified":1610023742501},{"_id":"public/img/cv1.jpg","hash":"2160c839498ddf205bdbeb0d612da9338fc39500","modified":1610023742505},{"_id":"public/css/aircloud.css.map","hash":"50db34961d11f6f461e23912609d25141068a6fc","modified":1610023742505},{"_id":"public/css/aircloud.less","hash":"45cab2da310dbfcba37ac3db657db77b4adac60d","modified":1610023742505},{"_id":"public/img/favicon.ico","hash":"6ed6db9af6e0d7b20e62a81d36d0556f47781d28","modified":1610023742505},{"_id":"public/img/1.jpg","hash":"f667d88d44741ff7b92ee9db5f1994bbcc05311c","modified":1610023742508},{"_id":"public/img/ker1.jpg","hash":"708e619ae0ad4524c41665f9930d3b8240d9ddcd","modified":1610023742511},{"_id":"public/js/index.js","hash":"1fed4485eedf5309e504aec35596955e5d692c7d","modified":1610023742514},{"_id":"public/css/gitment.css","hash":"926b553be983d6dd90bcb60c5d6d4ee215d268a6","modified":1610023742515},{"_id":"public/css/aircloud.css","hash":"e6082557a5f0e546169ab1aa0ba29bda4ef5c182","modified":1610023742515},{"_id":"public/js/gitment.js","hash":"89687f8fffe1125e08323fd6635ca4e53771c05e","modified":1610023742515},{"_id":"public/img/3.jpg","hash":"2de0cbd6ef6695f024865eb614e849641d369b87","modified":1610023742515},{"_id":"public/img/2.jpg","hash":"2f5b0345c366a264ed5b685e464a84e592ac0017","modified":1610023742515},{"_id":"public/img/avatar.jpg","hash":"5304e3982426a771746874abc1e70bc93261e197","modified":1610023742519},{"_id":"public/img/kds.jpg","hash":"70558c28dbc717528049673f7653804596e45fde","modified":1610023742519},{"_id":"public/img/donate.jpg","hash":"bae2b0f605495463a161716e35884b9c8f23a7a1","modified":1610023742529},{"_id":"public/img/kd.jpg","hash":"37b74057d1c06436c4c8c1b191b86ff6593fca16","modified":1610023742532}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2021-01-07T12:37:45.838Z","updated":"2021-01-07T12:36:24.365Z","path":"404.html","title":"","comments":1,"_id":"ckjmukdwf0000ffq9rws7wch2","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T20:48:33.000Z","comments":1,"_content":"\n\n>大多数时候，都在思考自己该走向何方\n\nE-mail: onlythen@yeah.net\n\nBrief：Javascript/Rust，不想做程序员的程序员，宏观经济研究者的男朋友\n\n* 2020.06.23\n\n有的时候，感觉机会其实也有很多，但是自己也许在默默流失，年初的时候疫情，带来医药股票的利好，但是自己没有买，春节结束后的第一天，明明是一次风险的释放，自己却也跟着卖了一些，导致损失了收益，其实每次危机中也都蕴藏着商机，希望之后的自己，可以多进行思考。\n\n* 2020.06.01\n\n**延迟反馈：**通常，当我们收到一个用户反馈一个问题的时候，已经有很多用户遇到这个问题了，他们通常默默忍受，或者默默走掉，不做声。并且很可能包括反馈问题的人在内，都已经尝试了很多次，在他们有限的认知下实在没有办法了，才来进行反馈。我们感谢这些发声的用户的同时，也应该审视，自己是否可以更早地发现这些问题。","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ncomments: true\n---\n\n\n>大多数时候，都在思考自己该走向何方\n\nE-mail: onlythen@yeah.net\n\nBrief：Javascript/Rust，不想做程序员的程序员，宏观经济研究者的男朋友\n\n* 2020.06.23\n\n有的时候，感觉机会其实也有很多，但是自己也许在默默流失，年初的时候疫情，带来医药股票的利好，但是自己没有买，春节结束后的第一天，明明是一次风险的释放，自己却也跟着卖了一些，导致损失了收益，其实每次危机中也都蕴藏着商机，希望之后的自己，可以多进行思考。\n\n* 2020.06.01\n\n**延迟反馈：**通常，当我们收到一个用户反馈一个问题的时候，已经有很多用户遇到这个问题了，他们通常默默忍受，或者默默走掉，不做声。并且很可能包括反馈问题的人在内，都已经尝试了很多次，在他们有限的认知下实在没有办法了，才来进行反馈。我们感谢这些发声的用户的同时，也应该审视，自己是否可以更早地发现这些问题。","updated":"2021-01-07T12:36:24.376Z","path":"about/index.html","_id":"ckjmukdws0001ffq91y5fhf32","content":"<blockquote>\n<p>大多数时候，都在思考自己该走向何方</p>\n</blockquote>\n<p>E-mail: <a href=\"mailto:onlythen@yeah.net\" target=\"_blank\" rel=\"noopener\">onlythen@yeah.net</a></p>\n<p>Brief：Javascript/Rust，不想做程序员的程序员，宏观经济研究者的男朋友</p>\n<ul>\n<li>2020.06.23</li>\n</ul>\n<p>有的时候，感觉机会其实也有很多，但是自己也许在默默流失，年初的时候疫情，带来医药股票的利好，但是自己没有买，春节结束后的第一天，明明是一次风险的释放，自己却也跟着卖了一些，导致损失了收益，其实每次危机中也都蕴藏着商机，希望之后的自己，可以多进行思考。</p>\n<ul>\n<li>2020.06.01</li>\n</ul>\n<p><strong>延迟反馈：</strong>通常，当我们收到一个用户反馈一个问题的时候，已经有很多用户遇到这个问题了，他们通常默默忍受，或者默默走掉，不做声。并且很可能包括反馈问题的人在内，都已经尝试了很多次，在他们有限的认知下实在没有办法了，才来进行反馈。我们感谢这些发声的用户的同时，也应该审视，自己是否可以更早地发现这些问题。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>大多数时候，都在思考自己该走向何方</p>\n</blockquote>\n<p>E-mail: <a href=\"mailto:onlythen@yeah.net\" target=\"_blank\" rel=\"noopener\">onlythen@yeah.net</a></p>\n<p>Brief：Javascript/Rust，不想做程序员的程序员，宏观经济研究者的男朋友</p>\n<ul>\n<li>2020.06.23</li>\n</ul>\n<p>有的时候，感觉机会其实也有很多，但是自己也许在默默流失，年初的时候疫情，带来医药股票的利好，但是自己没有买，春节结束后的第一天，明明是一次风险的释放，自己却也跟着卖了一些，导致损失了收益，其实每次危机中也都蕴藏着商机，希望之后的自己，可以多进行思考。</p>\n<ul>\n<li>2020.06.01</li>\n</ul>\n<p><strong>延迟反馈：</strong>通常，当我们收到一个用户反馈一个问题的时候，已经有很多用户遇到这个问题了，他们通常默默忍受，或者默默走掉，不做声。并且很可能包括反馈问题的人在内，都已经尝试了很多次，在他们有限的认知下实在没有办法了，才来进行反馈。我们感谢这些发声的用户的同时，也应该审视，自己是否可以更早地发现这些问题。</p>\n"},{"layout":"tags","title":"Tags","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\n---\n","date":"2021-01-07T12:37:45.804Z","updated":"2021-01-07T12:36:24.397Z","path":"tags/index.html","comments":1,"_id":"ckjmukdwy0003ffq9ojbxjffd","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"深入浏览器web渲染与优化-续","date":"2017-08-31T11:04:03.000Z","_content":">本篇文章接上一篇继续分析浏览器web渲染相关内容，但是更侧重优化工作。当然，主要还是基于X5来分析\n\n上一篇文章我们主要是从浏览器内核的线程角度来分析相关工作的，对整体流程没有宏观清晰的分析，这次我们从宏观到微观，从整体到局部，来进行分析和探究可以优化的地方。\n\n首先，一个网页的加载，需要什么工作呢？\n\n![](https://www.10000h.top/images/data_img/webRender2/P1.png)\n\n这个工作可以分为三部分：云(云端)、管(传输链路)、端(客户端)，从云经过管传到端，然后经过加载解析排版渲染，从而完成网页从请求到呈现的工作(当然，我们这里没有涉及协议的分析，实际上根据协议不同，这个传输可能是多次传输)。\n\n数据到端之后，又经过以下过程，才最终显示出来：\n\n![](https://www.10000h.top/images/data_img/webRender2/P2.png)\n\n在这个过程中，我们怎么衡量性能呢？\n\n固然，我们有诸多浏览器提供的API，这些API能让我们获取到较多信息并且记录上报：\n\n![](https://www.10000h.top/images/data_img/webRender2/P3.png)\n\n但是这些具体数值表达的含义有限，并且他们实际上也不等于用户体验。\n\n所以，找到一个科学并且可以检测的标准，并且这个标准可以和用户体验有正相关关系，这个是至关重要的。\n\n目前这个标准是**首屏时间**(就之前自己的了解，具体的还区分首屏展示时间和首屏可交互时间，但是这里讲师不做区分，就下文提供的测算方法而言，显然这里指的是首屏展示时间，*另外，展示后到用户的第一次操作都会有一个至少1s的延时，毕竟用户手指按下的动作是会比较慢的，这个时间js的交互都能完成了，所以首屏展示时间更加重要--from dorsywang*)\n\n那么**首屏时间**怎么测量呢？\n\n**拿摄像机快速拍照测量的**。这个答案可能有些吃惊，但是目前X5内核业务的相关开发人员的确就是采用这种方式测算的，通过高速相机不断拍照，然后辅助图像识别，判断首屏是否已经加载完成，最终再通过人工回归校对。  \n因为如果采用程序检测的话，基本上都会对过程本身造成一定的影响，所以没有采用这种方式。\n当然，通过摄像+图像识别的这种方式也是有一定的弊端，比如说，假设首屏有一个图片，而图片的加载通常比较慢并且不影响css、js的加载，这个时候直接通过图片识别的话就可能会有一定的误判。\n\n知道了怎么测算，那么接下来分析影响这个指标的一些原因：\n\n* 资源阻塞内核线程\n\n我们知道，一般情况下，css和JS是阻塞页面的，当然也会对首屏时间造成影响。\n\n对这个问题，X5内核有关键子资源(阻塞资源)缓存，这里的关键资源，指的是内核经过统计判断得出的业务常用的关键子资源。\n\n当然，这个统计也可能缺乏一定的准确性，所以相关团队也正在推进这方面的内容规范化(比如写入Web App Manifest)\n\n* 中文Layout的时间过长\n\n这个问题我之前没有听说过，但是的确是这样子，实际上，浏览器在绘制文字的时候经历的过程非常的多，其中有一个环节是找到文字的宽度和高度(因为在英文状态下，每一个字符的宽度是不同的，所以每一个字符都要查找，但是英文总共只有26个字符)，而中文由于字符比较多，常用得就有6000多个，完整的更是有2万个以上，所以这个过程需要花费更多的时间。\n\n为了解决这个问题，X5内核考虑到中文文字几乎都是等宽等高的，所以这个过程对一个文字串来说只需要查询一次即可，实际上是节约了这个环节。\n\n* 首次渲染太慢\n\n为了解决这个问题，可以采用先绘制首屏的方式，这个也就是基于第一篇文章中讲到的浏览器的分块渲染机制\n\n* 一次解析内容过多\n\n采用首屏探测机制，优先解析首屏内容。\n\n另外，这里可以前端配合去做首屏优化：\n\n\n在首屏的位置插入首屏标签，内核解析到标签后立即终止解析并且排版上屏\n\n```\n<meta name=‘x5-pagetype’ content=‘optpage'>\n```\n然后在首屏分界的地方：\n\n```\n<first-screen/>\n```\n\n有了这，可以专门去优化首屏标签之前的内容(这个标签前尽量展现耗时少和不需要阻塞解析的资源)。\n\n另外，X5内核也提供了主资源预拉取的接口，并且考虑到预拉取的cookie问题，还提供了preconnect预链接。  \n*TIP:主资源中关联的子资源预拉取不用主动调用*\n\n* 预先操作\n\n另外为了提供更加极致的优化，X5内核(QQ浏览器、手Q Webview)还提供了如下诸多预操作：\n\n* 在\"黏贴并转到\"之前就开始进行网络请求和预渲染\n* 经常访问的站点可以预解析DNS\n* 点击地址栏时进行搜索预连接\n* 点击链接时，先预链接，再做跳转。\n* ......\n\n### 其他方式优化\n\n实际上上文主要讲了客户端方面的优化工作，实际上对于\"云\"、\"管\"两端，还是有很多优化工作可以讲的，但是由于这个和前端关系不是特别密切，我挑一部分讲一讲。这些在我们前端做个人项目的后台时候也可以参考\n\n##### 后台提速\n\n* 直接使用IP，节省dns的查询时间\n* 维持长连接\n* HTTP1.1启用包头节省\n* 服务器缓存\n* 文本资源压缩传输GZIP(6)\n* 图片尺寸压缩、图片质量压缩、支持webp和sharpp/hevc格式。\n\n##### 降低网络时延\n\n* 就快接入和就近接入\n\n在选择接入点的时候，如果采用就近接入，可以保持路由稳定，有利于负载均衡，并且实现简单，便于维护。但是也有一定的缺点：经验判断，准确度不够高 ； 无法自动切换路由。\n\n相比较而言，选择就快接入，是一个能够提效的方式。\n\n##### 内容防劫持\n\n运营商劫持对我们来说已经是不陌生的话题了，但是X5内核有一个比较新的防劫持手段，就是客户端和云加速服务器同时采用轻量级http加密，虽然这种方式普适性不强，但是的确可以解决腾讯自身业务的防劫持问题。\n\n#### QUIC和http2\n\nQUIC 基于UDP的协议通讯方式，有这些优势：\n\n* 延迟少\n* 前向纠错\n* 没有**线头阻塞[注1]**的多路复用\n* 通信通道的定义基于ID而不是IP+端口，使得切换网络后继续转发链接成为可能\n\n——————\n\n注1：线头阻塞：\n\n![](https://www.10000h.top/images/data_img/webRender2/P4.png)\n\n——————\n\n附1: 带宽和延迟对网页加载的影响：\n\n![](https://www.10000h.top/images/data_img/webRender2/X1.png)\n","source":"_posts/深入浏览器web渲染与优化-续.md","raw":"---\ntitle: 深入浏览器web渲染与优化-续\ndate: 2017-08-31 19:04:03\ntags:\n    - 性能优化\n---\n>本篇文章接上一篇继续分析浏览器web渲染相关内容，但是更侧重优化工作。当然，主要还是基于X5来分析\n\n上一篇文章我们主要是从浏览器内核的线程角度来分析相关工作的，对整体流程没有宏观清晰的分析，这次我们从宏观到微观，从整体到局部，来进行分析和探究可以优化的地方。\n\n首先，一个网页的加载，需要什么工作呢？\n\n![](https://www.10000h.top/images/data_img/webRender2/P1.png)\n\n这个工作可以分为三部分：云(云端)、管(传输链路)、端(客户端)，从云经过管传到端，然后经过加载解析排版渲染，从而完成网页从请求到呈现的工作(当然，我们这里没有涉及协议的分析，实际上根据协议不同，这个传输可能是多次传输)。\n\n数据到端之后，又经过以下过程，才最终显示出来：\n\n![](https://www.10000h.top/images/data_img/webRender2/P2.png)\n\n在这个过程中，我们怎么衡量性能呢？\n\n固然，我们有诸多浏览器提供的API，这些API能让我们获取到较多信息并且记录上报：\n\n![](https://www.10000h.top/images/data_img/webRender2/P3.png)\n\n但是这些具体数值表达的含义有限，并且他们实际上也不等于用户体验。\n\n所以，找到一个科学并且可以检测的标准，并且这个标准可以和用户体验有正相关关系，这个是至关重要的。\n\n目前这个标准是**首屏时间**(就之前自己的了解，具体的还区分首屏展示时间和首屏可交互时间，但是这里讲师不做区分，就下文提供的测算方法而言，显然这里指的是首屏展示时间，*另外，展示后到用户的第一次操作都会有一个至少1s的延时，毕竟用户手指按下的动作是会比较慢的，这个时间js的交互都能完成了，所以首屏展示时间更加重要--from dorsywang*)\n\n那么**首屏时间**怎么测量呢？\n\n**拿摄像机快速拍照测量的**。这个答案可能有些吃惊，但是目前X5内核业务的相关开发人员的确就是采用这种方式测算的，通过高速相机不断拍照，然后辅助图像识别，判断首屏是否已经加载完成，最终再通过人工回归校对。  \n因为如果采用程序检测的话，基本上都会对过程本身造成一定的影响，所以没有采用这种方式。\n当然，通过摄像+图像识别的这种方式也是有一定的弊端，比如说，假设首屏有一个图片，而图片的加载通常比较慢并且不影响css、js的加载，这个时候直接通过图片识别的话就可能会有一定的误判。\n\n知道了怎么测算，那么接下来分析影响这个指标的一些原因：\n\n* 资源阻塞内核线程\n\n我们知道，一般情况下，css和JS是阻塞页面的，当然也会对首屏时间造成影响。\n\n对这个问题，X5内核有关键子资源(阻塞资源)缓存，这里的关键资源，指的是内核经过统计判断得出的业务常用的关键子资源。\n\n当然，这个统计也可能缺乏一定的准确性，所以相关团队也正在推进这方面的内容规范化(比如写入Web App Manifest)\n\n* 中文Layout的时间过长\n\n这个问题我之前没有听说过，但是的确是这样子，实际上，浏览器在绘制文字的时候经历的过程非常的多，其中有一个环节是找到文字的宽度和高度(因为在英文状态下，每一个字符的宽度是不同的，所以每一个字符都要查找，但是英文总共只有26个字符)，而中文由于字符比较多，常用得就有6000多个，完整的更是有2万个以上，所以这个过程需要花费更多的时间。\n\n为了解决这个问题，X5内核考虑到中文文字几乎都是等宽等高的，所以这个过程对一个文字串来说只需要查询一次即可，实际上是节约了这个环节。\n\n* 首次渲染太慢\n\n为了解决这个问题，可以采用先绘制首屏的方式，这个也就是基于第一篇文章中讲到的浏览器的分块渲染机制\n\n* 一次解析内容过多\n\n采用首屏探测机制，优先解析首屏内容。\n\n另外，这里可以前端配合去做首屏优化：\n\n\n在首屏的位置插入首屏标签，内核解析到标签后立即终止解析并且排版上屏\n\n```\n<meta name=‘x5-pagetype’ content=‘optpage'>\n```\n然后在首屏分界的地方：\n\n```\n<first-screen/>\n```\n\n有了这，可以专门去优化首屏标签之前的内容(这个标签前尽量展现耗时少和不需要阻塞解析的资源)。\n\n另外，X5内核也提供了主资源预拉取的接口，并且考虑到预拉取的cookie问题，还提供了preconnect预链接。  \n*TIP:主资源中关联的子资源预拉取不用主动调用*\n\n* 预先操作\n\n另外为了提供更加极致的优化，X5内核(QQ浏览器、手Q Webview)还提供了如下诸多预操作：\n\n* 在\"黏贴并转到\"之前就开始进行网络请求和预渲染\n* 经常访问的站点可以预解析DNS\n* 点击地址栏时进行搜索预连接\n* 点击链接时，先预链接，再做跳转。\n* ......\n\n### 其他方式优化\n\n实际上上文主要讲了客户端方面的优化工作，实际上对于\"云\"、\"管\"两端，还是有很多优化工作可以讲的，但是由于这个和前端关系不是特别密切，我挑一部分讲一讲。这些在我们前端做个人项目的后台时候也可以参考\n\n##### 后台提速\n\n* 直接使用IP，节省dns的查询时间\n* 维持长连接\n* HTTP1.1启用包头节省\n* 服务器缓存\n* 文本资源压缩传输GZIP(6)\n* 图片尺寸压缩、图片质量压缩、支持webp和sharpp/hevc格式。\n\n##### 降低网络时延\n\n* 就快接入和就近接入\n\n在选择接入点的时候，如果采用就近接入，可以保持路由稳定，有利于负载均衡，并且实现简单，便于维护。但是也有一定的缺点：经验判断，准确度不够高 ； 无法自动切换路由。\n\n相比较而言，选择就快接入，是一个能够提效的方式。\n\n##### 内容防劫持\n\n运营商劫持对我们来说已经是不陌生的话题了，但是X5内核有一个比较新的防劫持手段，就是客户端和云加速服务器同时采用轻量级http加密，虽然这种方式普适性不强，但是的确可以解决腾讯自身业务的防劫持问题。\n\n#### QUIC和http2\n\nQUIC 基于UDP的协议通讯方式，有这些优势：\n\n* 延迟少\n* 前向纠错\n* 没有**线头阻塞[注1]**的多路复用\n* 通信通道的定义基于ID而不是IP+端口，使得切换网络后继续转发链接成为可能\n\n——————\n\n注1：线头阻塞：\n\n![](https://www.10000h.top/images/data_img/webRender2/P4.png)\n\n——————\n\n附1: 带宽和延迟对网页加载的影响：\n\n![](https://www.10000h.top/images/data_img/webRender2/X1.png)\n","slug":"深入浏览器web渲染与优化-续","published":1,"updated":"2021-01-07T12:36:24.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjmukdwt0002ffq95am8elpd","content":"<blockquote>\n<p>本篇文章接上一篇继续分析浏览器web渲染相关内容，但是更侧重优化工作。当然，主要还是基于X5来分析</p>\n</blockquote>\n<p>上一篇文章我们主要是从浏览器内核的线程角度来分析相关工作的，对整体流程没有宏观清晰的分析，这次我们从宏观到微观，从整体到局部，来进行分析和探究可以优化的地方。</p>\n<p>首先，一个网页的加载，需要什么工作呢？</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/P1.png\" alt=\"\"></p>\n<p>这个工作可以分为三部分：云(云端)、管(传输链路)、端(客户端)，从云经过管传到端，然后经过加载解析排版渲染，从而完成网页从请求到呈现的工作(当然，我们这里没有涉及协议的分析，实际上根据协议不同，这个传输可能是多次传输)。</p>\n<p>数据到端之后，又经过以下过程，才最终显示出来：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/P2.png\" alt=\"\"></p>\n<p>在这个过程中，我们怎么衡量性能呢？</p>\n<p>固然，我们有诸多浏览器提供的API，这些API能让我们获取到较多信息并且记录上报：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/P3.png\" alt=\"\"></p>\n<p>但是这些具体数值表达的含义有限，并且他们实际上也不等于用户体验。</p>\n<p>所以，找到一个科学并且可以检测的标准，并且这个标准可以和用户体验有正相关关系，这个是至关重要的。</p>\n<p>目前这个标准是<strong>首屏时间</strong>(就之前自己的了解，具体的还区分首屏展示时间和首屏可交互时间，但是这里讲师不做区分，就下文提供的测算方法而言，显然这里指的是首屏展示时间，<em>另外，展示后到用户的第一次操作都会有一个至少1s的延时，毕竟用户手指按下的动作是会比较慢的，这个时间js的交互都能完成了，所以首屏展示时间更加重要–from dorsywang</em>)</p>\n<p>那么<strong>首屏时间</strong>怎么测量呢？</p>\n<p><strong>拿摄像机快速拍照测量的</strong>。这个答案可能有些吃惊，但是目前X5内核业务的相关开发人员的确就是采用这种方式测算的，通过高速相机不断拍照，然后辅助图像识别，判断首屏是否已经加载完成，最终再通过人工回归校对。<br>因为如果采用程序检测的话，基本上都会对过程本身造成一定的影响，所以没有采用这种方式。<br>当然，通过摄像+图像识别的这种方式也是有一定的弊端，比如说，假设首屏有一个图片，而图片的加载通常比较慢并且不影响css、js的加载，这个时候直接通过图片识别的话就可能会有一定的误判。</p>\n<p>知道了怎么测算，那么接下来分析影响这个指标的一些原因：</p>\n<ul>\n<li>资源阻塞内核线程</li>\n</ul>\n<p>我们知道，一般情况下，css和JS是阻塞页面的，当然也会对首屏时间造成影响。</p>\n<p>对这个问题，X5内核有关键子资源(阻塞资源)缓存，这里的关键资源，指的是内核经过统计判断得出的业务常用的关键子资源。</p>\n<p>当然，这个统计也可能缺乏一定的准确性，所以相关团队也正在推进这方面的内容规范化(比如写入Web App Manifest)</p>\n<ul>\n<li>中文Layout的时间过长</li>\n</ul>\n<p>这个问题我之前没有听说过，但是的确是这样子，实际上，浏览器在绘制文字的时候经历的过程非常的多，其中有一个环节是找到文字的宽度和高度(因为在英文状态下，每一个字符的宽度是不同的，所以每一个字符都要查找，但是英文总共只有26个字符)，而中文由于字符比较多，常用得就有6000多个，完整的更是有2万个以上，所以这个过程需要花费更多的时间。</p>\n<p>为了解决这个问题，X5内核考虑到中文文字几乎都是等宽等高的，所以这个过程对一个文字串来说只需要查询一次即可，实际上是节约了这个环节。</p>\n<ul>\n<li>首次渲染太慢</li>\n</ul>\n<p>为了解决这个问题，可以采用先绘制首屏的方式，这个也就是基于第一篇文章中讲到的浏览器的分块渲染机制</p>\n<ul>\n<li>一次解析内容过多</li>\n</ul>\n<p>采用首屏探测机制，优先解析首屏内容。</p>\n<p>另外，这里可以前端配合去做首屏优化：</p>\n<p>在首屏的位置插入首屏标签，内核解析到标签后立即终止解析并且排版上屏</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta <span class=\"attribute\">name</span>=‘x5-pagetype’ <span class=\"attribute\">content</span>=‘optpage'&gt;</span><br></pre></td></tr></table></figure>\n<p>然后在首屏分界的地方：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">&lt;first-screen/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>有了这，可以专门去优化首屏标签之前的内容(这个标签前尽量展现耗时少和不需要阻塞解析的资源)。</p>\n<p>另外，X5内核也提供了主资源预拉取的接口，并且考虑到预拉取的cookie问题，还提供了preconnect预链接。<br><em>TIP:主资源中关联的子资源预拉取不用主动调用</em></p>\n<ul>\n<li>预先操作</li>\n</ul>\n<p>另外为了提供更加极致的优化，X5内核(QQ浏览器、手Q Webview)还提供了如下诸多预操作：</p>\n<ul>\n<li>在”黏贴并转到”之前就开始进行网络请求和预渲染</li>\n<li>经常访问的站点可以预解析DNS</li>\n<li>点击地址栏时进行搜索预连接</li>\n<li>点击链接时，先预链接，再做跳转。</li>\n<li>……</li>\n</ul>\n<h3 id=\"其他方式优化\"><a href=\"#其他方式优化\" class=\"headerlink\" title=\"其他方式优化\"></a>其他方式优化</h3><p>实际上上文主要讲了客户端方面的优化工作，实际上对于”云”、”管”两端，还是有很多优化工作可以讲的，但是由于这个和前端关系不是特别密切，我挑一部分讲一讲。这些在我们前端做个人项目的后台时候也可以参考</p>\n<h5 id=\"后台提速\"><a href=\"#后台提速\" class=\"headerlink\" title=\"后台提速\"></a>后台提速</h5><ul>\n<li>直接使用IP，节省dns的查询时间</li>\n<li>维持长连接</li>\n<li>HTTP1.1启用包头节省</li>\n<li>服务器缓存</li>\n<li>文本资源压缩传输GZIP(6)</li>\n<li>图片尺寸压缩、图片质量压缩、支持webp和sharpp/hevc格式。</li>\n</ul>\n<h5 id=\"降低网络时延\"><a href=\"#降低网络时延\" class=\"headerlink\" title=\"降低网络时延\"></a>降低网络时延</h5><ul>\n<li>就快接入和就近接入</li>\n</ul>\n<p>在选择接入点的时候，如果采用就近接入，可以保持路由稳定，有利于负载均衡，并且实现简单，便于维护。但是也有一定的缺点：经验判断，准确度不够高 ； 无法自动切换路由。</p>\n<p>相比较而言，选择就快接入，是一个能够提效的方式。</p>\n<h5 id=\"内容防劫持\"><a href=\"#内容防劫持\" class=\"headerlink\" title=\"内容防劫持\"></a>内容防劫持</h5><p>运营商劫持对我们来说已经是不陌生的话题了，但是X5内核有一个比较新的防劫持手段，就是客户端和云加速服务器同时采用轻量级http加密，虽然这种方式普适性不强，但是的确可以解决腾讯自身业务的防劫持问题。</p>\n<h4 id=\"QUIC和http2\"><a href=\"#QUIC和http2\" class=\"headerlink\" title=\"QUIC和http2\"></a>QUIC和http2</h4><p>QUIC 基于UDP的协议通讯方式，有这些优势：</p>\n<ul>\n<li>延迟少</li>\n<li>前向纠错</li>\n<li>没有<strong>线头阻塞[注1]</strong>的多路复用</li>\n<li>通信通道的定义基于ID而不是IP+端口，使得切换网络后继续转发链接成为可能</li>\n</ul>\n<p>——————</p>\n<p>注1：线头阻塞：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/P4.png\" alt=\"\"></p>\n<p>——————</p>\n<p>附1: 带宽和延迟对网页加载的影响：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/X1.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本篇文章接上一篇继续分析浏览器web渲染相关内容，但是更侧重优化工作。当然，主要还是基于X5来分析</p>\n</blockquote>\n<p>上一篇文章我们主要是从浏览器内核的线程角度来分析相关工作的，对整体流程没有宏观清晰的分析，这次我们从宏观到微观，从整体到局部，来进行分析和探究可以优化的地方。</p>\n<p>首先，一个网页的加载，需要什么工作呢？</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/P1.png\" alt=\"\"></p>\n<p>这个工作可以分为三部分：云(云端)、管(传输链路)、端(客户端)，从云经过管传到端，然后经过加载解析排版渲染，从而完成网页从请求到呈现的工作(当然，我们这里没有涉及协议的分析，实际上根据协议不同，这个传输可能是多次传输)。</p>\n<p>数据到端之后，又经过以下过程，才最终显示出来：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/P2.png\" alt=\"\"></p>\n<p>在这个过程中，我们怎么衡量性能呢？</p>\n<p>固然，我们有诸多浏览器提供的API，这些API能让我们获取到较多信息并且记录上报：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/P3.png\" alt=\"\"></p>\n<p>但是这些具体数值表达的含义有限，并且他们实际上也不等于用户体验。</p>\n<p>所以，找到一个科学并且可以检测的标准，并且这个标准可以和用户体验有正相关关系，这个是至关重要的。</p>\n<p>目前这个标准是<strong>首屏时间</strong>(就之前自己的了解，具体的还区分首屏展示时间和首屏可交互时间，但是这里讲师不做区分，就下文提供的测算方法而言，显然这里指的是首屏展示时间，<em>另外，展示后到用户的第一次操作都会有一个至少1s的延时，毕竟用户手指按下的动作是会比较慢的，这个时间js的交互都能完成了，所以首屏展示时间更加重要–from dorsywang</em>)</p>\n<p>那么<strong>首屏时间</strong>怎么测量呢？</p>\n<p><strong>拿摄像机快速拍照测量的</strong>。这个答案可能有些吃惊，但是目前X5内核业务的相关开发人员的确就是采用这种方式测算的，通过高速相机不断拍照，然后辅助图像识别，判断首屏是否已经加载完成，最终再通过人工回归校对。<br>因为如果采用程序检测的话，基本上都会对过程本身造成一定的影响，所以没有采用这种方式。<br>当然，通过摄像+图像识别的这种方式也是有一定的弊端，比如说，假设首屏有一个图片，而图片的加载通常比较慢并且不影响css、js的加载，这个时候直接通过图片识别的话就可能会有一定的误判。</p>\n<p>知道了怎么测算，那么接下来分析影响这个指标的一些原因：</p>\n<ul>\n<li>资源阻塞内核线程</li>\n</ul>\n<p>我们知道，一般情况下，css和JS是阻塞页面的，当然也会对首屏时间造成影响。</p>\n<p>对这个问题，X5内核有关键子资源(阻塞资源)缓存，这里的关键资源，指的是内核经过统计判断得出的业务常用的关键子资源。</p>\n<p>当然，这个统计也可能缺乏一定的准确性，所以相关团队也正在推进这方面的内容规范化(比如写入Web App Manifest)</p>\n<ul>\n<li>中文Layout的时间过长</li>\n</ul>\n<p>这个问题我之前没有听说过，但是的确是这样子，实际上，浏览器在绘制文字的时候经历的过程非常的多，其中有一个环节是找到文字的宽度和高度(因为在英文状态下，每一个字符的宽度是不同的，所以每一个字符都要查找，但是英文总共只有26个字符)，而中文由于字符比较多，常用得就有6000多个，完整的更是有2万个以上，所以这个过程需要花费更多的时间。</p>\n<p>为了解决这个问题，X5内核考虑到中文文字几乎都是等宽等高的，所以这个过程对一个文字串来说只需要查询一次即可，实际上是节约了这个环节。</p>\n<ul>\n<li>首次渲染太慢</li>\n</ul>\n<p>为了解决这个问题，可以采用先绘制首屏的方式，这个也就是基于第一篇文章中讲到的浏览器的分块渲染机制</p>\n<ul>\n<li>一次解析内容过多</li>\n</ul>\n<p>采用首屏探测机制，优先解析首屏内容。</p>\n<p>另外，这里可以前端配合去做首屏优化：</p>\n<p>在首屏的位置插入首屏标签，内核解析到标签后立即终止解析并且排版上屏</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta <span class=\"attribute\">name</span>=‘x5-pagetype’ <span class=\"attribute\">content</span>=‘optpage'&gt;</span><br></pre></td></tr></table></figure>\n<p>然后在首屏分界的地方：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">&lt;first-screen/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>有了这，可以专门去优化首屏标签之前的内容(这个标签前尽量展现耗时少和不需要阻塞解析的资源)。</p>\n<p>另外，X5内核也提供了主资源预拉取的接口，并且考虑到预拉取的cookie问题，还提供了preconnect预链接。<br><em>TIP:主资源中关联的子资源预拉取不用主动调用</em></p>\n<ul>\n<li>预先操作</li>\n</ul>\n<p>另外为了提供更加极致的优化，X5内核(QQ浏览器、手Q Webview)还提供了如下诸多预操作：</p>\n<ul>\n<li>在”黏贴并转到”之前就开始进行网络请求和预渲染</li>\n<li>经常访问的站点可以预解析DNS</li>\n<li>点击地址栏时进行搜索预连接</li>\n<li>点击链接时，先预链接，再做跳转。</li>\n<li>……</li>\n</ul>\n<h3 id=\"其他方式优化\"><a href=\"#其他方式优化\" class=\"headerlink\" title=\"其他方式优化\"></a>其他方式优化</h3><p>实际上上文主要讲了客户端方面的优化工作，实际上对于”云”、”管”两端，还是有很多优化工作可以讲的，但是由于这个和前端关系不是特别密切，我挑一部分讲一讲。这些在我们前端做个人项目的后台时候也可以参考</p>\n<h5 id=\"后台提速\"><a href=\"#后台提速\" class=\"headerlink\" title=\"后台提速\"></a>后台提速</h5><ul>\n<li>直接使用IP，节省dns的查询时间</li>\n<li>维持长连接</li>\n<li>HTTP1.1启用包头节省</li>\n<li>服务器缓存</li>\n<li>文本资源压缩传输GZIP(6)</li>\n<li>图片尺寸压缩、图片质量压缩、支持webp和sharpp/hevc格式。</li>\n</ul>\n<h5 id=\"降低网络时延\"><a href=\"#降低网络时延\" class=\"headerlink\" title=\"降低网络时延\"></a>降低网络时延</h5><ul>\n<li>就快接入和就近接入</li>\n</ul>\n<p>在选择接入点的时候，如果采用就近接入，可以保持路由稳定，有利于负载均衡，并且实现简单，便于维护。但是也有一定的缺点：经验判断，准确度不够高 ； 无法自动切换路由。</p>\n<p>相比较而言，选择就快接入，是一个能够提效的方式。</p>\n<h5 id=\"内容防劫持\"><a href=\"#内容防劫持\" class=\"headerlink\" title=\"内容防劫持\"></a>内容防劫持</h5><p>运营商劫持对我们来说已经是不陌生的话题了，但是X5内核有一个比较新的防劫持手段，就是客户端和云加速服务器同时采用轻量级http加密，虽然这种方式普适性不强，但是的确可以解决腾讯自身业务的防劫持问题。</p>\n<h4 id=\"QUIC和http2\"><a href=\"#QUIC和http2\" class=\"headerlink\" title=\"QUIC和http2\"></a>QUIC和http2</h4><p>QUIC 基于UDP的协议通讯方式，有这些优势：</p>\n<ul>\n<li>延迟少</li>\n<li>前向纠错</li>\n<li>没有<strong>线头阻塞[注1]</strong>的多路复用</li>\n<li>通信通道的定义基于ID而不是IP+端口，使得切换网络后继续转发链接成为可能</li>\n</ul>\n<p>——————</p>\n<p>注1：线头阻塞：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/P4.png\" alt=\"\"></p>\n<p>——————</p>\n<p>附1: 带宽和延迟对网页加载的影响：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/X1.png\" alt=\"\"></p>\n"},{"title":"深入浏览器web渲染与优化","date":"2017-08-27T09:37:22.000Z","_content":">本文主要分析和总结web内核渲染的相关内容，以及在这方面前端可以做的性能优化工作。\n\n文章主要分为以下几个部分：\n\n* blink内核的渲染机制\n* chrome内核架构变迁\n* 分层渲染\n* 动画 & canvas & WebGl\n\n*这里的前两部分可能会有些枯燥，如果是前端工程师并且想立即获得实际项目的建议的，可以直接阅读第三部分和第四部分*\n\n### blink内核的渲染机制\n\nblink内核是Google基于Webkit内核开发的新的分支，而实际上，目前Chrome已经采用了blink内核，所以，我们接下来的有关分析大多基于blink内核的浏览器(Chrome)，就不再详细指明，当然，部分内容也会涉及到腾讯研发的X5内核(X5内核基于安卓的WebView，目前已经在手机QQ等产品中使用，基于X5内核的项目累计有数亿UV，上百亿PV)。\n\n一个页面的显示，实际上主要经历了下面的四个流程：\n\n加载 => 解析 => 排版 => 渲染\n\n实际上，这里的渲染主要是指排版之后到最后的上屏绘制(这个时候内容已经排版好了)，一部分前端工程师通常会把一部分的排版工作理解到“渲染”的流程中(也就是下图中全部工作)，实际上这个理解是不准确的。\n\n![](https://www.10000h.top/images/data_img/webRender/P6.PNG)\n\n目前，浏览器的渲染采用的是分块渲染的机制，所谓的分块渲染的机制，其实应该这么理解：\n\n* 浏览器首先把整个网页分成一些低分辨率的块，再把网页分成高分辨率的块，然后给这些块排列优先级。\n* 处在可视区域内的低分辨率块的优先级会比较高，会被较先绘制。\n* 之后浏览器会把高分辨率的块进行绘制，同样也是先绘制处于可视区域内的，再绘制可视区域外的(由近到远)。\n\n以上讲的这些策略可以使可以使得浏览器优先展示可视区域内的内容，并且先展示大致内容，再展示高精度内容(当然，由于这个过程比较快，实际上我们大多时候是感受不到的)。\n\n另外这里值得提醒的一点是，分块的优先级是会根据到可视区域的距离来决定的，所以有些横着的内容(比如banner的滚动实现，通常会设置横向超出屏幕来表示隐藏)，也是会按照到可视区域的距离来决定优先级的。\n\n绘制的过程，可以被硬件加速，这里硬件加速的主要手段主要是指：\n\n* 硬件加速合成上屏\n* 2D Canvas、Video的硬件加速\n* GPU光栅化\n\t* GPU光栅化速度更快，内存和CPU的消耗更少\n\t* 目前还没有办法对包含复杂矢量绘制的页面进行GPU光栅化\n\t* GPU光栅化是未来趋势\n\n\n### chrome内核架构变迁\n\n在渲染架构上，chrome也是经历了诸多变迁，早期的Chrome是这样的：\n\n![](https://www.10000h.top/images/data_img/webRender/P1.PNG)\n\n早期的chrome的架构实际上有以下缺点：\n\n* Renderer线程任务繁重\n* 无法实时响应缩放滑动操作\n* 脏区域与滑动重绘区域有冲突\n\t* 这里举个场景，假设一个gif，这个时候如果用户滑动，滑动新的需要绘制的内容和gif下一帧内容就会产生绘制冲突\n\n当然，经过一系列的发展，Chrome现在是这样的：\n\n![](https://www.10000h.top/images/data_img/webRender/P2.PNG)\n\n在安卓上，Android 4.4的 Blink内核架构如下(4.4之前并不支持OpenGL)\n\n![](https://www.10000h.top/images/data_img/webRender/P3.PNG)\n\n当然，这种架构也有如下缺点：\n\n* UI线程过于繁忙\n* 无法支持Canvas的硬件加速以及WebGL\n\n所以，后期发展成了这样：\n\n![](https://www.10000h.top/images/data_img/webRender/P4.PNG)\n\n总结看来，内核发展的趋势是：\n\n* 多线程化(可以充分利用多核心CPU)\n* 硬件加速(可以利用GPU)\n\n### 分层渲染\n\n在阅读这一章之前，我建议读者先去亲自体验一下所谓的“分层渲染”：\n\n>打开Chrome浏览器，打开控制台，找到\"Layers\"，如果没有，那么在控制台右上角更多的图标->More tools 找到\"Layers\"，然后随便找个网页打开即可\n\n网页的分层渲染流程主要是下面这样的：\n\n![](https://www.10000h.top/images/data_img/webRender/P7.PNG)\n\n(*注意：多个RenderObject可能又会对应一个或多个RenderLayer*)\n\n既然才用了分层渲染，那么肯定可以来分层处理，分层渲染有如下优点：\n\n* 减少不必要的重新绘制\n* 可以实现较为复杂的动画\n* 能够方便实现复杂的CSS样式\n\n当然，分层渲染是会很影响渲染效率的，可以有好的影响，使用不当也会有差的影响，我们需要合理的控制和使用分层：\n\n* 如果小豆腐块分层较多，页面整体的分层数量较大，会导致每帧渲染时遍历分层和计算分层位置耗时较长啊(比较典型的是腾讯网移动端首页)。\n* 如果可视区域内分层太多且需要绘制的面积太大，渲染性能非常差，甚至无法达到正常显示的地步(比如有一些全屏H5)。\n* 如果页面几乎没有分层，页面变化时候需要重绘的区域较多。元素内容无变化只有位置发生变化的时候，可以利用分层来避免重绘。\n\n那么，是什么原因可以导致分层呢？目前每一个浏览器或者不同版本的浏览器分层策略都是有些不同的(虽然总体差不太多)，但最常见的几个分层原因是：transform、Z-index；还有可以使用硬件加速的video、canvas；fixed元素；混合插件(flash等)。关于其他更具体的内容，可以见下文。\n\n```\n//注:Chrome中符合创建新层的情况：\nLayer has 3D or perspective transform CSS properties(有3D元素的属性)\nLayer is used by <video> element using accelerated video decoding(video标签并使用加速视频解码)\nLayer is used by a <canvas> element with a 3D context or accelerated 2D context(canvas元素并启用3D)\nLayer is used for a composited plugin(插件，比如flash)\nLayer uses a CSS animation for its opacity or uses an animated webkit transform(CSS动画)\nLayer uses accelerated CSS filters(CSS滤镜)\nLayer with a composited descendant has information that needs to be in the composited layer tree, such as a clip or reflection(有一个后代元素是独立的layer)\nLayer has a sibling with a lower z-index which has a compositing layer (in other words the layer is rendered on top of a composited layer)(元素的相邻元素是独立layer)\n```\n\n最后，我们总结一下如何合理的设计分层：分层总的原则是，减少渲染重绘面积与减少分层个数和分层总面积：\n\n* 相对位置会发生变化的元素需要分层(比如banner图、滚动条)\n* 元素内容更新比较频繁的需要分层(比如页面中夹杂的倒计时等)\n* 较长较大的页面注意总的分层个数\n* 避免某一块区域分层过多，面积过大\n\n(*如果你给一个元素添加上了-webkit-transform: translateZ(0);或者 -webkit-transform: translate3d(0,0,0);属性，那么你就等于告诉了浏览器用GPU来渲染该层，与一般的CPU渲染相比，提升了速度和性能。(我很确定这么做会在Chrome中启用了硬件加速，但在其他平台不做保证。就我得到的资料而言，在大多数浏览器比如Firefox、Safari也是适用的)*)\n\n另外值得一提的是，X5对分层方面做了一定的优化工作，当其检测到分层过多可能会出现显示问题的时候会进行层合并，牺牲显示性能换取显示正确性。\n\n最后再提出一个小问题：\n\n以下哪种渲染方式是最优的呢？\n\n![](https://www.10000h.top/images/data_img/webRender/P8.PNG)\n\n这里实际上后者虽然在分层上满足总体原则，但是之前讲到浏览器的分块渲染机制，是按照到可视区域的距离排序的，考虑到这个因素，实际上后者这种方式可能会对分块渲染造成一定的困扰，并且也不是最优的。\n\n### 动画 & canvas & WebGl\n\n讲最后一部分开始，首先抛出一个问题：CSS动画 or JS动画?\n\n对内核来说，实际上就是Renderer线程动画还是Compositor线程动画，二者实际上过程如下：\n\n![](https://www.10000h.top/images/data_img/webRender/P9.PNG)\n\n所以我们可以看出，Renderer线程是比Compositor线程动画性能差的(在中低端尤其明显)\n\n另外，无论是JS动画还是CSS动画，动画过程中的重绘以及样式变化都会拖慢动画执行以及引起卡顿\n以下是一些不会触发重绘或者排版的CSS动画属性：\n\n* cursor\n* font-variant\n* opacity\n* orphans\n* perspective\n* perspecti-origin\n* pointer-events\n* transform\n* transform-style\n* widows\n\n想要了解更多内容，可以参考[这里](https://csstriggers.com/)\n\n这方面最终的建议参考如下：\n\n* 尽量使用不会引起重绘的CSS属性动画，例如transform、opacity等\n* 动画一定要避免触发大量元素重新排版或者大面积重绘\n* 在有动画执行时，避免其他动画不相关因素引起排版和重绘\n\n\n#### requestAnimationFrame\n\n另外当我们在使用动画的时候，为了避免出现掉帧的情况，最好采用requestAnimationFrame这个API，这个API迎合浏览器的流程，并且能够保证在下一帧绘制的时候上一帧一定出现了：\n\n![](https://www.10000h.top/images/data_img/webRender/P11.PNG)\n\n### 3D canvas\n\n还有值得注意的是，有的时候我们需要涉及大量元素的动画(比如雪花飘落、多个不规则图形变化等)，这个时候如果用CSS动画，Animation动画的元素很多。，导致分层个数非常多，浏览器每帧都需要遍历计算所有分层，导致比较耗时、\n\n这个时候该怎么办呢？\n\n2D canvas上场。 \n\n和CSS动画相比，2D canvas的优点是这样的：\n\n* 硬件加速渲染\n* 渲染流程更优\n\n其渲染流程如下：\n\n![](https://www.10000h.top/images/data_img/webRender/P10.PNG)\n\n实际上以上流程比较耗时的是JS Call这一部分，执行opengl的这一部分还是挺快的。\n\nHTML 2D canvas 主要绘制如下三种元素：\n\n* 图片\n* 文字\n* 矢量\n\n这个过程可以采用硬件加速，硬件加速图片绘制的主要流程：\n\n![](https://www.10000h.top/images/data_img/webRender/P12.PNG)\n\n硬件加速文字绘制的主要流程：\n\n![](https://www.10000h.top/images/data_img/webRender/P13.PNG)\n\n但对于矢量绘制而言，简单的图形，比如点、直线等可以直接使用OpenGL渲染，复杂的图形，如曲线等，无法采用OpenGL绘制。\n\n对于绘制效率来说，2D Canvas对绘制图片效率较高，绘制文字和矢量效率较低(**所以建议是，我们如果能使用贴图就尽量使用贴图了**)\n\n还有，有的时候我们需要先绘制到离屏canvas上面，然后再上屏，这个可以充分利用缓存。\n\n### 3D canvas(WebGL)\n\n目前，3D canvas(WebGL)的应用也越来越多，对于这类应用，现在已经有了不少已经成型的庫:\n\n\n* 通用引擎：threeJS、Pixi\n* VR视频的专业引擎：krpano、UtoVR\n* H5游戏引擎：Egret、Layabox、Cocos\n\nWebGL虽然包含Web，但本身对前端的要求最低，但是对OpenGL、数学相关的知识要求较高，所以如果前端工程师没有一定的基础，还是采用现在的流行庫。\n\nX5内核对于WebGl进行了性能上和耗电上的优化，并且也对兼容性错误上报和修复做了一定的工作。\n\n___\n\n本文参考腾讯内部讲座资料整理而成，并融入一部分笔者的补充，谢绝任何形式的转载。\n\n其他优质好文：\n\n[Javascript高性能动画与页面渲染](http://qingbob.com/javascript-high-performance-animation-and-page-rendering/)\n\n\n","source":"_posts/深入浏览器web渲染与优化.md","raw":"---\ntitle: 深入浏览器web渲染与优化\ndate: 2017-08-27 17:37:22\ntags:\n    - 性能优化\n---\n>本文主要分析和总结web内核渲染的相关内容，以及在这方面前端可以做的性能优化工作。\n\n文章主要分为以下几个部分：\n\n* blink内核的渲染机制\n* chrome内核架构变迁\n* 分层渲染\n* 动画 & canvas & WebGl\n\n*这里的前两部分可能会有些枯燥，如果是前端工程师并且想立即获得实际项目的建议的，可以直接阅读第三部分和第四部分*\n\n### blink内核的渲染机制\n\nblink内核是Google基于Webkit内核开发的新的分支，而实际上，目前Chrome已经采用了blink内核，所以，我们接下来的有关分析大多基于blink内核的浏览器(Chrome)，就不再详细指明，当然，部分内容也会涉及到腾讯研发的X5内核(X5内核基于安卓的WebView，目前已经在手机QQ等产品中使用，基于X5内核的项目累计有数亿UV，上百亿PV)。\n\n一个页面的显示，实际上主要经历了下面的四个流程：\n\n加载 => 解析 => 排版 => 渲染\n\n实际上，这里的渲染主要是指排版之后到最后的上屏绘制(这个时候内容已经排版好了)，一部分前端工程师通常会把一部分的排版工作理解到“渲染”的流程中(也就是下图中全部工作)，实际上这个理解是不准确的。\n\n![](https://www.10000h.top/images/data_img/webRender/P6.PNG)\n\n目前，浏览器的渲染采用的是分块渲染的机制，所谓的分块渲染的机制，其实应该这么理解：\n\n* 浏览器首先把整个网页分成一些低分辨率的块，再把网页分成高分辨率的块，然后给这些块排列优先级。\n* 处在可视区域内的低分辨率块的优先级会比较高，会被较先绘制。\n* 之后浏览器会把高分辨率的块进行绘制，同样也是先绘制处于可视区域内的，再绘制可视区域外的(由近到远)。\n\n以上讲的这些策略可以使可以使得浏览器优先展示可视区域内的内容，并且先展示大致内容，再展示高精度内容(当然，由于这个过程比较快，实际上我们大多时候是感受不到的)。\n\n另外这里值得提醒的一点是，分块的优先级是会根据到可视区域的距离来决定的，所以有些横着的内容(比如banner的滚动实现，通常会设置横向超出屏幕来表示隐藏)，也是会按照到可视区域的距离来决定优先级的。\n\n绘制的过程，可以被硬件加速，这里硬件加速的主要手段主要是指：\n\n* 硬件加速合成上屏\n* 2D Canvas、Video的硬件加速\n* GPU光栅化\n\t* GPU光栅化速度更快，内存和CPU的消耗更少\n\t* 目前还没有办法对包含复杂矢量绘制的页面进行GPU光栅化\n\t* GPU光栅化是未来趋势\n\n\n### chrome内核架构变迁\n\n在渲染架构上，chrome也是经历了诸多变迁，早期的Chrome是这样的：\n\n![](https://www.10000h.top/images/data_img/webRender/P1.PNG)\n\n早期的chrome的架构实际上有以下缺点：\n\n* Renderer线程任务繁重\n* 无法实时响应缩放滑动操作\n* 脏区域与滑动重绘区域有冲突\n\t* 这里举个场景，假设一个gif，这个时候如果用户滑动，滑动新的需要绘制的内容和gif下一帧内容就会产生绘制冲突\n\n当然，经过一系列的发展，Chrome现在是这样的：\n\n![](https://www.10000h.top/images/data_img/webRender/P2.PNG)\n\n在安卓上，Android 4.4的 Blink内核架构如下(4.4之前并不支持OpenGL)\n\n![](https://www.10000h.top/images/data_img/webRender/P3.PNG)\n\n当然，这种架构也有如下缺点：\n\n* UI线程过于繁忙\n* 无法支持Canvas的硬件加速以及WebGL\n\n所以，后期发展成了这样：\n\n![](https://www.10000h.top/images/data_img/webRender/P4.PNG)\n\n总结看来，内核发展的趋势是：\n\n* 多线程化(可以充分利用多核心CPU)\n* 硬件加速(可以利用GPU)\n\n### 分层渲染\n\n在阅读这一章之前，我建议读者先去亲自体验一下所谓的“分层渲染”：\n\n>打开Chrome浏览器，打开控制台，找到\"Layers\"，如果没有，那么在控制台右上角更多的图标->More tools 找到\"Layers\"，然后随便找个网页打开即可\n\n网页的分层渲染流程主要是下面这样的：\n\n![](https://www.10000h.top/images/data_img/webRender/P7.PNG)\n\n(*注意：多个RenderObject可能又会对应一个或多个RenderLayer*)\n\n既然才用了分层渲染，那么肯定可以来分层处理，分层渲染有如下优点：\n\n* 减少不必要的重新绘制\n* 可以实现较为复杂的动画\n* 能够方便实现复杂的CSS样式\n\n当然，分层渲染是会很影响渲染效率的，可以有好的影响，使用不当也会有差的影响，我们需要合理的控制和使用分层：\n\n* 如果小豆腐块分层较多，页面整体的分层数量较大，会导致每帧渲染时遍历分层和计算分层位置耗时较长啊(比较典型的是腾讯网移动端首页)。\n* 如果可视区域内分层太多且需要绘制的面积太大，渲染性能非常差，甚至无法达到正常显示的地步(比如有一些全屏H5)。\n* 如果页面几乎没有分层，页面变化时候需要重绘的区域较多。元素内容无变化只有位置发生变化的时候，可以利用分层来避免重绘。\n\n那么，是什么原因可以导致分层呢？目前每一个浏览器或者不同版本的浏览器分层策略都是有些不同的(虽然总体差不太多)，但最常见的几个分层原因是：transform、Z-index；还有可以使用硬件加速的video、canvas；fixed元素；混合插件(flash等)。关于其他更具体的内容，可以见下文。\n\n```\n//注:Chrome中符合创建新层的情况：\nLayer has 3D or perspective transform CSS properties(有3D元素的属性)\nLayer is used by <video> element using accelerated video decoding(video标签并使用加速视频解码)\nLayer is used by a <canvas> element with a 3D context or accelerated 2D context(canvas元素并启用3D)\nLayer is used for a composited plugin(插件，比如flash)\nLayer uses a CSS animation for its opacity or uses an animated webkit transform(CSS动画)\nLayer uses accelerated CSS filters(CSS滤镜)\nLayer with a composited descendant has information that needs to be in the composited layer tree, such as a clip or reflection(有一个后代元素是独立的layer)\nLayer has a sibling with a lower z-index which has a compositing layer (in other words the layer is rendered on top of a composited layer)(元素的相邻元素是独立layer)\n```\n\n最后，我们总结一下如何合理的设计分层：分层总的原则是，减少渲染重绘面积与减少分层个数和分层总面积：\n\n* 相对位置会发生变化的元素需要分层(比如banner图、滚动条)\n* 元素内容更新比较频繁的需要分层(比如页面中夹杂的倒计时等)\n* 较长较大的页面注意总的分层个数\n* 避免某一块区域分层过多，面积过大\n\n(*如果你给一个元素添加上了-webkit-transform: translateZ(0);或者 -webkit-transform: translate3d(0,0,0);属性，那么你就等于告诉了浏览器用GPU来渲染该层，与一般的CPU渲染相比，提升了速度和性能。(我很确定这么做会在Chrome中启用了硬件加速，但在其他平台不做保证。就我得到的资料而言，在大多数浏览器比如Firefox、Safari也是适用的)*)\n\n另外值得一提的是，X5对分层方面做了一定的优化工作，当其检测到分层过多可能会出现显示问题的时候会进行层合并，牺牲显示性能换取显示正确性。\n\n最后再提出一个小问题：\n\n以下哪种渲染方式是最优的呢？\n\n![](https://www.10000h.top/images/data_img/webRender/P8.PNG)\n\n这里实际上后者虽然在分层上满足总体原则，但是之前讲到浏览器的分块渲染机制，是按照到可视区域的距离排序的，考虑到这个因素，实际上后者这种方式可能会对分块渲染造成一定的困扰，并且也不是最优的。\n\n### 动画 & canvas & WebGl\n\n讲最后一部分开始，首先抛出一个问题：CSS动画 or JS动画?\n\n对内核来说，实际上就是Renderer线程动画还是Compositor线程动画，二者实际上过程如下：\n\n![](https://www.10000h.top/images/data_img/webRender/P9.PNG)\n\n所以我们可以看出，Renderer线程是比Compositor线程动画性能差的(在中低端尤其明显)\n\n另外，无论是JS动画还是CSS动画，动画过程中的重绘以及样式变化都会拖慢动画执行以及引起卡顿\n以下是一些不会触发重绘或者排版的CSS动画属性：\n\n* cursor\n* font-variant\n* opacity\n* orphans\n* perspective\n* perspecti-origin\n* pointer-events\n* transform\n* transform-style\n* widows\n\n想要了解更多内容，可以参考[这里](https://csstriggers.com/)\n\n这方面最终的建议参考如下：\n\n* 尽量使用不会引起重绘的CSS属性动画，例如transform、opacity等\n* 动画一定要避免触发大量元素重新排版或者大面积重绘\n* 在有动画执行时，避免其他动画不相关因素引起排版和重绘\n\n\n#### requestAnimationFrame\n\n另外当我们在使用动画的时候，为了避免出现掉帧的情况，最好采用requestAnimationFrame这个API，这个API迎合浏览器的流程，并且能够保证在下一帧绘制的时候上一帧一定出现了：\n\n![](https://www.10000h.top/images/data_img/webRender/P11.PNG)\n\n### 3D canvas\n\n还有值得注意的是，有的时候我们需要涉及大量元素的动画(比如雪花飘落、多个不规则图形变化等)，这个时候如果用CSS动画，Animation动画的元素很多。，导致分层个数非常多，浏览器每帧都需要遍历计算所有分层，导致比较耗时、\n\n这个时候该怎么办呢？\n\n2D canvas上场。 \n\n和CSS动画相比，2D canvas的优点是这样的：\n\n* 硬件加速渲染\n* 渲染流程更优\n\n其渲染流程如下：\n\n![](https://www.10000h.top/images/data_img/webRender/P10.PNG)\n\n实际上以上流程比较耗时的是JS Call这一部分，执行opengl的这一部分还是挺快的。\n\nHTML 2D canvas 主要绘制如下三种元素：\n\n* 图片\n* 文字\n* 矢量\n\n这个过程可以采用硬件加速，硬件加速图片绘制的主要流程：\n\n![](https://www.10000h.top/images/data_img/webRender/P12.PNG)\n\n硬件加速文字绘制的主要流程：\n\n![](https://www.10000h.top/images/data_img/webRender/P13.PNG)\n\n但对于矢量绘制而言，简单的图形，比如点、直线等可以直接使用OpenGL渲染，复杂的图形，如曲线等，无法采用OpenGL绘制。\n\n对于绘制效率来说，2D Canvas对绘制图片效率较高，绘制文字和矢量效率较低(**所以建议是，我们如果能使用贴图就尽量使用贴图了**)\n\n还有，有的时候我们需要先绘制到离屏canvas上面，然后再上屏，这个可以充分利用缓存。\n\n### 3D canvas(WebGL)\n\n目前，3D canvas(WebGL)的应用也越来越多，对于这类应用，现在已经有了不少已经成型的庫:\n\n\n* 通用引擎：threeJS、Pixi\n* VR视频的专业引擎：krpano、UtoVR\n* H5游戏引擎：Egret、Layabox、Cocos\n\nWebGL虽然包含Web，但本身对前端的要求最低，但是对OpenGL、数学相关的知识要求较高，所以如果前端工程师没有一定的基础，还是采用现在的流行庫。\n\nX5内核对于WebGl进行了性能上和耗电上的优化，并且也对兼容性错误上报和修复做了一定的工作。\n\n___\n\n本文参考腾讯内部讲座资料整理而成，并融入一部分笔者的补充，谢绝任何形式的转载。\n\n其他优质好文：\n\n[Javascript高性能动画与页面渲染](http://qingbob.com/javascript-high-performance-animation-and-page-rendering/)\n\n\n","slug":"深入浏览器web渲染与优化","published":1,"updated":"2021-01-07T12:36:24.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjmukdwy0004ffq9i8iu5atm","content":"<blockquote>\n<p>本文主要分析和总结web内核渲染的相关内容，以及在这方面前端可以做的性能优化工作。</p>\n</blockquote>\n<p>文章主要分为以下几个部分：</p>\n<ul>\n<li>blink内核的渲染机制</li>\n<li>chrome内核架构变迁</li>\n<li>分层渲染</li>\n<li>动画 &amp; canvas &amp; WebGl</li>\n</ul>\n<p><em>这里的前两部分可能会有些枯燥，如果是前端工程师并且想立即获得实际项目的建议的，可以直接阅读第三部分和第四部分</em></p>\n<h3 id=\"blink内核的渲染机制\"><a href=\"#blink内核的渲染机制\" class=\"headerlink\" title=\"blink内核的渲染机制\"></a>blink内核的渲染机制</h3><p>blink内核是Google基于Webkit内核开发的新的分支，而实际上，目前Chrome已经采用了blink内核，所以，我们接下来的有关分析大多基于blink内核的浏览器(Chrome)，就不再详细指明，当然，部分内容也会涉及到腾讯研发的X5内核(X5内核基于安卓的WebView，目前已经在手机QQ等产品中使用，基于X5内核的项目累计有数亿UV，上百亿PV)。</p>\n<p>一个页面的显示，实际上主要经历了下面的四个流程：</p>\n<p>加载 =&gt; 解析 =&gt; 排版 =&gt; 渲染</p>\n<p>实际上，这里的渲染主要是指排版之后到最后的上屏绘制(这个时候内容已经排版好了)，一部分前端工程师通常会把一部分的排版工作理解到“渲染”的流程中(也就是下图中全部工作)，实际上这个理解是不准确的。</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P6.PNG\" alt=\"\"></p>\n<p>目前，浏览器的渲染采用的是分块渲染的机制，所谓的分块渲染的机制，其实应该这么理解：</p>\n<ul>\n<li>浏览器首先把整个网页分成一些低分辨率的块，再把网页分成高分辨率的块，然后给这些块排列优先级。</li>\n<li>处在可视区域内的低分辨率块的优先级会比较高，会被较先绘制。</li>\n<li>之后浏览器会把高分辨率的块进行绘制，同样也是先绘制处于可视区域内的，再绘制可视区域外的(由近到远)。</li>\n</ul>\n<p>以上讲的这些策略可以使可以使得浏览器优先展示可视区域内的内容，并且先展示大致内容，再展示高精度内容(当然，由于这个过程比较快，实际上我们大多时候是感受不到的)。</p>\n<p>另外这里值得提醒的一点是，分块的优先级是会根据到可视区域的距离来决定的，所以有些横着的内容(比如banner的滚动实现，通常会设置横向超出屏幕来表示隐藏)，也是会按照到可视区域的距离来决定优先级的。</p>\n<p>绘制的过程，可以被硬件加速，这里硬件加速的主要手段主要是指：</p>\n<ul>\n<li>硬件加速合成上屏</li>\n<li>2D Canvas、Video的硬件加速</li>\n<li>GPU光栅化<ul>\n<li>GPU光栅化速度更快，内存和CPU的消耗更少</li>\n<li>目前还没有办法对包含复杂矢量绘制的页面进行GPU光栅化</li>\n<li>GPU光栅化是未来趋势</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"chrome内核架构变迁\"><a href=\"#chrome内核架构变迁\" class=\"headerlink\" title=\"chrome内核架构变迁\"></a>chrome内核架构变迁</h3><p>在渲染架构上，chrome也是经历了诸多变迁，早期的Chrome是这样的：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P1.PNG\" alt=\"\"></p>\n<p>早期的chrome的架构实际上有以下缺点：</p>\n<ul>\n<li>Renderer线程任务繁重</li>\n<li>无法实时响应缩放滑动操作</li>\n<li>脏区域与滑动重绘区域有冲突<ul>\n<li>这里举个场景，假设一个gif，这个时候如果用户滑动，滑动新的需要绘制的内容和gif下一帧内容就会产生绘制冲突</li>\n</ul>\n</li>\n</ul>\n<p>当然，经过一系列的发展，Chrome现在是这样的：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P2.PNG\" alt=\"\"></p>\n<p>在安卓上，Android 4.4的 Blink内核架构如下(4.4之前并不支持OpenGL)</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P3.PNG\" alt=\"\"></p>\n<p>当然，这种架构也有如下缺点：</p>\n<ul>\n<li>UI线程过于繁忙</li>\n<li>无法支持Canvas的硬件加速以及WebGL</li>\n</ul>\n<p>所以，后期发展成了这样：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P4.PNG\" alt=\"\"></p>\n<p>总结看来，内核发展的趋势是：</p>\n<ul>\n<li>多线程化(可以充分利用多核心CPU)</li>\n<li>硬件加速(可以利用GPU)</li>\n</ul>\n<h3 id=\"分层渲染\"><a href=\"#分层渲染\" class=\"headerlink\" title=\"分层渲染\"></a>分层渲染</h3><p>在阅读这一章之前，我建议读者先去亲自体验一下所谓的“分层渲染”：</p>\n<blockquote>\n<p>打开Chrome浏览器，打开控制台，找到”Layers”，如果没有，那么在控制台右上角更多的图标-&gt;More tools 找到”Layers”，然后随便找个网页打开即可</p>\n</blockquote>\n<p>网页的分层渲染流程主要是下面这样的：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P7.PNG\" alt=\"\"></p>\n<p>(<em>注意：多个RenderObject可能又会对应一个或多个RenderLayer</em>)</p>\n<p>既然才用了分层渲染，那么肯定可以来分层处理，分层渲染有如下优点：</p>\n<ul>\n<li>减少不必要的重新绘制</li>\n<li>可以实现较为复杂的动画</li>\n<li>能够方便实现复杂的CSS样式</li>\n</ul>\n<p>当然，分层渲染是会很影响渲染效率的，可以有好的影响，使用不当也会有差的影响，我们需要合理的控制和使用分层：</p>\n<ul>\n<li>如果小豆腐块分层较多，页面整体的分层数量较大，会导致每帧渲染时遍历分层和计算分层位置耗时较长啊(比较典型的是腾讯网移动端首页)。</li>\n<li>如果可视区域内分层太多且需要绘制的面积太大，渲染性能非常差，甚至无法达到正常显示的地步(比如有一些全屏H5)。</li>\n<li>如果页面几乎没有分层，页面变化时候需要重绘的区域较多。元素内容无变化只有位置发生变化的时候，可以利用分层来避免重绘。</li>\n</ul>\n<p>那么，是什么原因可以导致分层呢？目前每一个浏览器或者不同版本的浏览器分层策略都是有些不同的(虽然总体差不太多)，但最常见的几个分层原因是：transform、Z-index；还有可以使用硬件加速的video、canvas；fixed元素；混合插件(flash等)。关于其他更具体的内容，可以见下文。</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//注:Chrome中符合创建新层的情况：</span><br><span class=\"line\">Layer has <span class=\"number\">3</span>D <span class=\"keyword\">or</span> perspective transform CSS properties(有<span class=\"number\">3</span>D元素的属性)</span><br><span class=\"line\">Layer is used <span class=\"keyword\">by</span> &lt;video&gt; <span class=\"keyword\">element</span> <span class=\"keyword\">using</span> accelerated video decoding(video标签并使用加速视频解码)</span><br><span class=\"line\">Layer is used <span class=\"keyword\">by</span> <span class=\"keyword\">a</span> &lt;canvas&gt; <span class=\"keyword\">element</span> <span class=\"keyword\">with</span> <span class=\"keyword\">a</span> <span class=\"number\">3</span>D context <span class=\"keyword\">or</span> accelerated <span class=\"number\">2</span>D context(canvas元素并启用<span class=\"number\">3</span>D)</span><br><span class=\"line\">Layer is used <span class=\"keyword\">for</span> <span class=\"keyword\">a</span> composited plugin(插件，比如flash)</span><br><span class=\"line\">Layer uses <span class=\"keyword\">a</span> CSS animation <span class=\"keyword\">for</span> its opacity <span class=\"keyword\">or</span> uses <span class=\"keyword\">an</span> animated webkit transform(CSS动画)</span><br><span class=\"line\">Layer uses accelerated CSS filters(CSS滤镜)</span><br><span class=\"line\">Layer <span class=\"keyword\">with</span> <span class=\"keyword\">a</span> composited descendant has information that needs <span class=\"built_in\">to</span> be <span class=\"keyword\">in</span> <span class=\"keyword\">the</span> composited layer tree, such <span class=\"keyword\">as</span> <span class=\"keyword\">a</span> clip <span class=\"keyword\">or</span> reflection(有一个后代元素是独立的layer)</span><br><span class=\"line\">Layer has <span class=\"keyword\">a</span> sibling <span class=\"keyword\">with</span> <span class=\"keyword\">a</span> <span class=\"built_in\">lower</span> z-index which has <span class=\"keyword\">a</span> compositing layer (<span class=\"keyword\">in</span> other <span class=\"keyword\">words</span> <span class=\"keyword\">the</span> layer is rendered <span class=\"keyword\">on</span> <span class=\"title\">top</span> <span class=\"title\">of</span> <span class=\"title\">a</span> <span class=\"title\">composited</span> <span class=\"title\">layer</span>)(元素的相邻元素是独立<span class=\"title\">layer</span>)</span><br></pre></td></tr></table></figure>\n<p>最后，我们总结一下如何合理的设计分层：分层总的原则是，减少渲染重绘面积与减少分层个数和分层总面积：</p>\n<ul>\n<li>相对位置会发生变化的元素需要分层(比如banner图、滚动条)</li>\n<li>元素内容更新比较频繁的需要分层(比如页面中夹杂的倒计时等)</li>\n<li>较长较大的页面注意总的分层个数</li>\n<li>避免某一块区域分层过多，面积过大</li>\n</ul>\n<p>(<em>如果你给一个元素添加上了-webkit-transform: translateZ(0);或者 -webkit-transform: translate3d(0,0,0);属性，那么你就等于告诉了浏览器用GPU来渲染该层，与一般的CPU渲染相比，提升了速度和性能。(我很确定这么做会在Chrome中启用了硬件加速，但在其他平台不做保证。就我得到的资料而言，在大多数浏览器比如Firefox、Safari也是适用的)</em>)</p>\n<p>另外值得一提的是，X5对分层方面做了一定的优化工作，当其检测到分层过多可能会出现显示问题的时候会进行层合并，牺牲显示性能换取显示正确性。</p>\n<p>最后再提出一个小问题：</p>\n<p>以下哪种渲染方式是最优的呢？</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P8.PNG\" alt=\"\"></p>\n<p>这里实际上后者虽然在分层上满足总体原则，但是之前讲到浏览器的分块渲染机制，是按照到可视区域的距离排序的，考虑到这个因素，实际上后者这种方式可能会对分块渲染造成一定的困扰，并且也不是最优的。</p>\n<h3 id=\"动画-amp-canvas-amp-WebGl\"><a href=\"#动画-amp-canvas-amp-WebGl\" class=\"headerlink\" title=\"动画 &amp; canvas &amp; WebGl\"></a>动画 &amp; canvas &amp; WebGl</h3><p>讲最后一部分开始，首先抛出一个问题：CSS动画 or JS动画?</p>\n<p>对内核来说，实际上就是Renderer线程动画还是Compositor线程动画，二者实际上过程如下：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P9.PNG\" alt=\"\"></p>\n<p>所以我们可以看出，Renderer线程是比Compositor线程动画性能差的(在中低端尤其明显)</p>\n<p>另外，无论是JS动画还是CSS动画，动画过程中的重绘以及样式变化都会拖慢动画执行以及引起卡顿<br>以下是一些不会触发重绘或者排版的CSS动画属性：</p>\n<ul>\n<li>cursor</li>\n<li>font-variant</li>\n<li>opacity</li>\n<li>orphans</li>\n<li>perspective</li>\n<li>perspecti-origin</li>\n<li>pointer-events</li>\n<li>transform</li>\n<li>transform-style</li>\n<li>widows</li>\n</ul>\n<p>想要了解更多内容，可以参考<a href=\"https://csstriggers.com/\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<p>这方面最终的建议参考如下：</p>\n<ul>\n<li>尽量使用不会引起重绘的CSS属性动画，例如transform、opacity等</li>\n<li>动画一定要避免触发大量元素重新排版或者大面积重绘</li>\n<li>在有动画执行时，避免其他动画不相关因素引起排版和重绘</li>\n</ul>\n<h4 id=\"requestAnimationFrame\"><a href=\"#requestAnimationFrame\" class=\"headerlink\" title=\"requestAnimationFrame\"></a>requestAnimationFrame</h4><p>另外当我们在使用动画的时候，为了避免出现掉帧的情况，最好采用requestAnimationFrame这个API，这个API迎合浏览器的流程，并且能够保证在下一帧绘制的时候上一帧一定出现了：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P11.PNG\" alt=\"\"></p>\n<h3 id=\"3D-canvas\"><a href=\"#3D-canvas\" class=\"headerlink\" title=\"3D canvas\"></a>3D canvas</h3><p>还有值得注意的是，有的时候我们需要涉及大量元素的动画(比如雪花飘落、多个不规则图形变化等)，这个时候如果用CSS动画，Animation动画的元素很多。，导致分层个数非常多，浏览器每帧都需要遍历计算所有分层，导致比较耗时、</p>\n<p>这个时候该怎么办呢？</p>\n<p>2D canvas上场。 </p>\n<p>和CSS动画相比，2D canvas的优点是这样的：</p>\n<ul>\n<li>硬件加速渲染</li>\n<li>渲染流程更优</li>\n</ul>\n<p>其渲染流程如下：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P10.PNG\" alt=\"\"></p>\n<p>实际上以上流程比较耗时的是JS Call这一部分，执行opengl的这一部分还是挺快的。</p>\n<p>HTML 2D canvas 主要绘制如下三种元素：</p>\n<ul>\n<li>图片</li>\n<li>文字</li>\n<li>矢量</li>\n</ul>\n<p>这个过程可以采用硬件加速，硬件加速图片绘制的主要流程：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P12.PNG\" alt=\"\"></p>\n<p>硬件加速文字绘制的主要流程：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P13.PNG\" alt=\"\"></p>\n<p>但对于矢量绘制而言，简单的图形，比如点、直线等可以直接使用OpenGL渲染，复杂的图形，如曲线等，无法采用OpenGL绘制。</p>\n<p>对于绘制效率来说，2D Canvas对绘制图片效率较高，绘制文字和矢量效率较低(<strong>所以建议是，我们如果能使用贴图就尽量使用贴图了</strong>)</p>\n<p>还有，有的时候我们需要先绘制到离屏canvas上面，然后再上屏，这个可以充分利用缓存。</p>\n<h3 id=\"3D-canvas-WebGL\"><a href=\"#3D-canvas-WebGL\" class=\"headerlink\" title=\"3D canvas(WebGL)\"></a>3D canvas(WebGL)</h3><p>目前，3D canvas(WebGL)的应用也越来越多，对于这类应用，现在已经有了不少已经成型的庫:</p>\n<ul>\n<li>通用引擎：threeJS、Pixi</li>\n<li>VR视频的专业引擎：krpano、UtoVR</li>\n<li>H5游戏引擎：Egret、Layabox、Cocos</li>\n</ul>\n<p>WebGL虽然包含Web，但本身对前端的要求最低，但是对OpenGL、数学相关的知识要求较高，所以如果前端工程师没有一定的基础，还是采用现在的流行庫。</p>\n<p>X5内核对于WebGl进行了性能上和耗电上的优化，并且也对兼容性错误上报和修复做了一定的工作。</p>\n<hr>\n<p>本文参考腾讯内部讲座资料整理而成，并融入一部分笔者的补充，谢绝任何形式的转载。</p>\n<p>其他优质好文：</p>\n<p><a href=\"http://qingbob.com/javascript-high-performance-animation-and-page-rendering/\" target=\"_blank\" rel=\"noopener\">Javascript高性能动画与页面渲染</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本文主要分析和总结web内核渲染的相关内容，以及在这方面前端可以做的性能优化工作。</p>\n</blockquote>\n<p>文章主要分为以下几个部分：</p>\n<ul>\n<li>blink内核的渲染机制</li>\n<li>chrome内核架构变迁</li>\n<li>分层渲染</li>\n<li>动画 &amp; canvas &amp; WebGl</li>\n</ul>\n<p><em>这里的前两部分可能会有些枯燥，如果是前端工程师并且想立即获得实际项目的建议的，可以直接阅读第三部分和第四部分</em></p>\n<h3 id=\"blink内核的渲染机制\"><a href=\"#blink内核的渲染机制\" class=\"headerlink\" title=\"blink内核的渲染机制\"></a>blink内核的渲染机制</h3><p>blink内核是Google基于Webkit内核开发的新的分支，而实际上，目前Chrome已经采用了blink内核，所以，我们接下来的有关分析大多基于blink内核的浏览器(Chrome)，就不再详细指明，当然，部分内容也会涉及到腾讯研发的X5内核(X5内核基于安卓的WebView，目前已经在手机QQ等产品中使用，基于X5内核的项目累计有数亿UV，上百亿PV)。</p>\n<p>一个页面的显示，实际上主要经历了下面的四个流程：</p>\n<p>加载 =&gt; 解析 =&gt; 排版 =&gt; 渲染</p>\n<p>实际上，这里的渲染主要是指排版之后到最后的上屏绘制(这个时候内容已经排版好了)，一部分前端工程师通常会把一部分的排版工作理解到“渲染”的流程中(也就是下图中全部工作)，实际上这个理解是不准确的。</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P6.PNG\" alt=\"\"></p>\n<p>目前，浏览器的渲染采用的是分块渲染的机制，所谓的分块渲染的机制，其实应该这么理解：</p>\n<ul>\n<li>浏览器首先把整个网页分成一些低分辨率的块，再把网页分成高分辨率的块，然后给这些块排列优先级。</li>\n<li>处在可视区域内的低分辨率块的优先级会比较高，会被较先绘制。</li>\n<li>之后浏览器会把高分辨率的块进行绘制，同样也是先绘制处于可视区域内的，再绘制可视区域外的(由近到远)。</li>\n</ul>\n<p>以上讲的这些策略可以使可以使得浏览器优先展示可视区域内的内容，并且先展示大致内容，再展示高精度内容(当然，由于这个过程比较快，实际上我们大多时候是感受不到的)。</p>\n<p>另外这里值得提醒的一点是，分块的优先级是会根据到可视区域的距离来决定的，所以有些横着的内容(比如banner的滚动实现，通常会设置横向超出屏幕来表示隐藏)，也是会按照到可视区域的距离来决定优先级的。</p>\n<p>绘制的过程，可以被硬件加速，这里硬件加速的主要手段主要是指：</p>\n<ul>\n<li>硬件加速合成上屏</li>\n<li>2D Canvas、Video的硬件加速</li>\n<li>GPU光栅化<ul>\n<li>GPU光栅化速度更快，内存和CPU的消耗更少</li>\n<li>目前还没有办法对包含复杂矢量绘制的页面进行GPU光栅化</li>\n<li>GPU光栅化是未来趋势</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"chrome内核架构变迁\"><a href=\"#chrome内核架构变迁\" class=\"headerlink\" title=\"chrome内核架构变迁\"></a>chrome内核架构变迁</h3><p>在渲染架构上，chrome也是经历了诸多变迁，早期的Chrome是这样的：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P1.PNG\" alt=\"\"></p>\n<p>早期的chrome的架构实际上有以下缺点：</p>\n<ul>\n<li>Renderer线程任务繁重</li>\n<li>无法实时响应缩放滑动操作</li>\n<li>脏区域与滑动重绘区域有冲突<ul>\n<li>这里举个场景，假设一个gif，这个时候如果用户滑动，滑动新的需要绘制的内容和gif下一帧内容就会产生绘制冲突</li>\n</ul>\n</li>\n</ul>\n<p>当然，经过一系列的发展，Chrome现在是这样的：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P2.PNG\" alt=\"\"></p>\n<p>在安卓上，Android 4.4的 Blink内核架构如下(4.4之前并不支持OpenGL)</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P3.PNG\" alt=\"\"></p>\n<p>当然，这种架构也有如下缺点：</p>\n<ul>\n<li>UI线程过于繁忙</li>\n<li>无法支持Canvas的硬件加速以及WebGL</li>\n</ul>\n<p>所以，后期发展成了这样：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P4.PNG\" alt=\"\"></p>\n<p>总结看来，内核发展的趋势是：</p>\n<ul>\n<li>多线程化(可以充分利用多核心CPU)</li>\n<li>硬件加速(可以利用GPU)</li>\n</ul>\n<h3 id=\"分层渲染\"><a href=\"#分层渲染\" class=\"headerlink\" title=\"分层渲染\"></a>分层渲染</h3><p>在阅读这一章之前，我建议读者先去亲自体验一下所谓的“分层渲染”：</p>\n<blockquote>\n<p>打开Chrome浏览器，打开控制台，找到”Layers”，如果没有，那么在控制台右上角更多的图标-&gt;More tools 找到”Layers”，然后随便找个网页打开即可</p>\n</blockquote>\n<p>网页的分层渲染流程主要是下面这样的：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P7.PNG\" alt=\"\"></p>\n<p>(<em>注意：多个RenderObject可能又会对应一个或多个RenderLayer</em>)</p>\n<p>既然才用了分层渲染，那么肯定可以来分层处理，分层渲染有如下优点：</p>\n<ul>\n<li>减少不必要的重新绘制</li>\n<li>可以实现较为复杂的动画</li>\n<li>能够方便实现复杂的CSS样式</li>\n</ul>\n<p>当然，分层渲染是会很影响渲染效率的，可以有好的影响，使用不当也会有差的影响，我们需要合理的控制和使用分层：</p>\n<ul>\n<li>如果小豆腐块分层较多，页面整体的分层数量较大，会导致每帧渲染时遍历分层和计算分层位置耗时较长啊(比较典型的是腾讯网移动端首页)。</li>\n<li>如果可视区域内分层太多且需要绘制的面积太大，渲染性能非常差，甚至无法达到正常显示的地步(比如有一些全屏H5)。</li>\n<li>如果页面几乎没有分层，页面变化时候需要重绘的区域较多。元素内容无变化只有位置发生变化的时候，可以利用分层来避免重绘。</li>\n</ul>\n<p>那么，是什么原因可以导致分层呢？目前每一个浏览器或者不同版本的浏览器分层策略都是有些不同的(虽然总体差不太多)，但最常见的几个分层原因是：transform、Z-index；还有可以使用硬件加速的video、canvas；fixed元素；混合插件(flash等)。关于其他更具体的内容，可以见下文。</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//注:Chrome中符合创建新层的情况：</span><br><span class=\"line\">Layer has <span class=\"number\">3</span>D <span class=\"keyword\">or</span> perspective transform CSS properties(有<span class=\"number\">3</span>D元素的属性)</span><br><span class=\"line\">Layer is used <span class=\"keyword\">by</span> &lt;video&gt; <span class=\"keyword\">element</span> <span class=\"keyword\">using</span> accelerated video decoding(video标签并使用加速视频解码)</span><br><span class=\"line\">Layer is used <span class=\"keyword\">by</span> <span class=\"keyword\">a</span> &lt;canvas&gt; <span class=\"keyword\">element</span> <span class=\"keyword\">with</span> <span class=\"keyword\">a</span> <span class=\"number\">3</span>D context <span class=\"keyword\">or</span> accelerated <span class=\"number\">2</span>D context(canvas元素并启用<span class=\"number\">3</span>D)</span><br><span class=\"line\">Layer is used <span class=\"keyword\">for</span> <span class=\"keyword\">a</span> composited plugin(插件，比如flash)</span><br><span class=\"line\">Layer uses <span class=\"keyword\">a</span> CSS animation <span class=\"keyword\">for</span> its opacity <span class=\"keyword\">or</span> uses <span class=\"keyword\">an</span> animated webkit transform(CSS动画)</span><br><span class=\"line\">Layer uses accelerated CSS filters(CSS滤镜)</span><br><span class=\"line\">Layer <span class=\"keyword\">with</span> <span class=\"keyword\">a</span> composited descendant has information that needs <span class=\"built_in\">to</span> be <span class=\"keyword\">in</span> <span class=\"keyword\">the</span> composited layer tree, such <span class=\"keyword\">as</span> <span class=\"keyword\">a</span> clip <span class=\"keyword\">or</span> reflection(有一个后代元素是独立的layer)</span><br><span class=\"line\">Layer has <span class=\"keyword\">a</span> sibling <span class=\"keyword\">with</span> <span class=\"keyword\">a</span> <span class=\"built_in\">lower</span> z-index which has <span class=\"keyword\">a</span> compositing layer (<span class=\"keyword\">in</span> other <span class=\"keyword\">words</span> <span class=\"keyword\">the</span> layer is rendered <span class=\"keyword\">on</span> <span class=\"title\">top</span> <span class=\"title\">of</span> <span class=\"title\">a</span> <span class=\"title\">composited</span> <span class=\"title\">layer</span>)(元素的相邻元素是独立<span class=\"title\">layer</span>)</span><br></pre></td></tr></table></figure>\n<p>最后，我们总结一下如何合理的设计分层：分层总的原则是，减少渲染重绘面积与减少分层个数和分层总面积：</p>\n<ul>\n<li>相对位置会发生变化的元素需要分层(比如banner图、滚动条)</li>\n<li>元素内容更新比较频繁的需要分层(比如页面中夹杂的倒计时等)</li>\n<li>较长较大的页面注意总的分层个数</li>\n<li>避免某一块区域分层过多，面积过大</li>\n</ul>\n<p>(<em>如果你给一个元素添加上了-webkit-transform: translateZ(0);或者 -webkit-transform: translate3d(0,0,0);属性，那么你就等于告诉了浏览器用GPU来渲染该层，与一般的CPU渲染相比，提升了速度和性能。(我很确定这么做会在Chrome中启用了硬件加速，但在其他平台不做保证。就我得到的资料而言，在大多数浏览器比如Firefox、Safari也是适用的)</em>)</p>\n<p>另外值得一提的是，X5对分层方面做了一定的优化工作，当其检测到分层过多可能会出现显示问题的时候会进行层合并，牺牲显示性能换取显示正确性。</p>\n<p>最后再提出一个小问题：</p>\n<p>以下哪种渲染方式是最优的呢？</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P8.PNG\" alt=\"\"></p>\n<p>这里实际上后者虽然在分层上满足总体原则，但是之前讲到浏览器的分块渲染机制，是按照到可视区域的距离排序的，考虑到这个因素，实际上后者这种方式可能会对分块渲染造成一定的困扰，并且也不是最优的。</p>\n<h3 id=\"动画-amp-canvas-amp-WebGl\"><a href=\"#动画-amp-canvas-amp-WebGl\" class=\"headerlink\" title=\"动画 &amp; canvas &amp; WebGl\"></a>动画 &amp; canvas &amp; WebGl</h3><p>讲最后一部分开始，首先抛出一个问题：CSS动画 or JS动画?</p>\n<p>对内核来说，实际上就是Renderer线程动画还是Compositor线程动画，二者实际上过程如下：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P9.PNG\" alt=\"\"></p>\n<p>所以我们可以看出，Renderer线程是比Compositor线程动画性能差的(在中低端尤其明显)</p>\n<p>另外，无论是JS动画还是CSS动画，动画过程中的重绘以及样式变化都会拖慢动画执行以及引起卡顿<br>以下是一些不会触发重绘或者排版的CSS动画属性：</p>\n<ul>\n<li>cursor</li>\n<li>font-variant</li>\n<li>opacity</li>\n<li>orphans</li>\n<li>perspective</li>\n<li>perspecti-origin</li>\n<li>pointer-events</li>\n<li>transform</li>\n<li>transform-style</li>\n<li>widows</li>\n</ul>\n<p>想要了解更多内容，可以参考<a href=\"https://csstriggers.com/\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<p>这方面最终的建议参考如下：</p>\n<ul>\n<li>尽量使用不会引起重绘的CSS属性动画，例如transform、opacity等</li>\n<li>动画一定要避免触发大量元素重新排版或者大面积重绘</li>\n<li>在有动画执行时，避免其他动画不相关因素引起排版和重绘</li>\n</ul>\n<h4 id=\"requestAnimationFrame\"><a href=\"#requestAnimationFrame\" class=\"headerlink\" title=\"requestAnimationFrame\"></a>requestAnimationFrame</h4><p>另外当我们在使用动画的时候，为了避免出现掉帧的情况，最好采用requestAnimationFrame这个API，这个API迎合浏览器的流程，并且能够保证在下一帧绘制的时候上一帧一定出现了：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P11.PNG\" alt=\"\"></p>\n<h3 id=\"3D-canvas\"><a href=\"#3D-canvas\" class=\"headerlink\" title=\"3D canvas\"></a>3D canvas</h3><p>还有值得注意的是，有的时候我们需要涉及大量元素的动画(比如雪花飘落、多个不规则图形变化等)，这个时候如果用CSS动画，Animation动画的元素很多。，导致分层个数非常多，浏览器每帧都需要遍历计算所有分层，导致比较耗时、</p>\n<p>这个时候该怎么办呢？</p>\n<p>2D canvas上场。 </p>\n<p>和CSS动画相比，2D canvas的优点是这样的：</p>\n<ul>\n<li>硬件加速渲染</li>\n<li>渲染流程更优</li>\n</ul>\n<p>其渲染流程如下：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P10.PNG\" alt=\"\"></p>\n<p>实际上以上流程比较耗时的是JS Call这一部分，执行opengl的这一部分还是挺快的。</p>\n<p>HTML 2D canvas 主要绘制如下三种元素：</p>\n<ul>\n<li>图片</li>\n<li>文字</li>\n<li>矢量</li>\n</ul>\n<p>这个过程可以采用硬件加速，硬件加速图片绘制的主要流程：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P12.PNG\" alt=\"\"></p>\n<p>硬件加速文字绘制的主要流程：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P13.PNG\" alt=\"\"></p>\n<p>但对于矢量绘制而言，简单的图形，比如点、直线等可以直接使用OpenGL渲染，复杂的图形，如曲线等，无法采用OpenGL绘制。</p>\n<p>对于绘制效率来说，2D Canvas对绘制图片效率较高，绘制文字和矢量效率较低(<strong>所以建议是，我们如果能使用贴图就尽量使用贴图了</strong>)</p>\n<p>还有，有的时候我们需要先绘制到离屏canvas上面，然后再上屏，这个可以充分利用缓存。</p>\n<h3 id=\"3D-canvas-WebGL\"><a href=\"#3D-canvas-WebGL\" class=\"headerlink\" title=\"3D canvas(WebGL)\"></a>3D canvas(WebGL)</h3><p>目前，3D canvas(WebGL)的应用也越来越多，对于这类应用，现在已经有了不少已经成型的庫:</p>\n<ul>\n<li>通用引擎：threeJS、Pixi</li>\n<li>VR视频的专业引擎：krpano、UtoVR</li>\n<li>H5游戏引擎：Egret、Layabox、Cocos</li>\n</ul>\n<p>WebGL虽然包含Web，但本身对前端的要求最低，但是对OpenGL、数学相关的知识要求较高，所以如果前端工程师没有一定的基础，还是采用现在的流行庫。</p>\n<p>X5内核对于WebGl进行了性能上和耗电上的优化，并且也对兼容性错误上报和修复做了一定的工作。</p>\n<hr>\n<p>本文参考腾讯内部讲座资料整理而成，并融入一部分笔者的补充，谢绝任何形式的转载。</p>\n<p>其他优质好文：</p>\n<p><a href=\"http://qingbob.com/javascript-high-performance-animation-and-page-rendering/\" target=\"_blank\" rel=\"noopener\">Javascript高性能动画与页面渲染</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckjmukdwt0002ffq95am8elpd","tag_id":"ckjmukdx10005ffq91v2t7mgi","_id":"ckjmukdx40007ffq96w7yom1k"},{"post_id":"ckjmukdwy0004ffq9i8iu5atm","tag_id":"ckjmukdx10005ffq91v2t7mgi","_id":"ckjmukdx50008ffq9gg16tfq4"}],"Tag":[{"name":"性能优化","_id":"ckjmukdx10005ffq91v2t7mgi"}]}}